using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Collections;



class Board
{
    public static readonly uint bombTimer = 8;

    public Grid Grid;
    public int playersAmm;
    public int timer;

    public Move[] guessedMoves;
    public List<Point> bombs;
    public List<Entity> extraBombs;
    public Entity[] players;
    public int[] scores;
    public int[] upgrades;
    public int remainingBoxes;
    public bool Terminal
    {
        get
        {
            int killed = 0;
            foreach (Entity player in players)
                if (player.empty)
                    killed++;
            return killed >= playersAmm - 1;
        }
    }

    public Grid copiedGrid;

    public Board(uint width, uint height)
    {
        Grid = new Grid(width, height);
        copiedGrid = new Grid(width, height);

        bombs = new List<Point>();
        extraBombs = new List<Entity>();




        remainingBoxes = 0;
        timer = 0;
    }

    public void SetPlayersAmm(int p)
    {
        playersAmm = p;
        players = new Entity[playersAmm];
        upgrades = new int[playersAmm];
        scores = new int[playersAmm];
        guessedMoves = new Move[playersAmm];
    }


    public Board Copy()
    {
        Board res = new Board(Grid.width, Grid.height);
        res.SetPlayersAmm(playersAmm);
        Grid.CopyTo(res.Grid);
        res.bombs = bombs.ConvertAll(b => b);
        res.extraBombs = extraBombs.ConvertAll(b => b);

        upgrades.CopyTo(res.upgrades, 0);
        players.CopyTo(res.players, 0);
        scores.CopyTo(res.scores, 0);
        res.remainingBoxes = remainingBoxes;
        res.timer = timer;
        return res;
    }

    public bool PointInRange(Point p, Entity bomb)
    {
        bool obstr = false;
        int bx = bomb.position.x;
        int by = bomb.position.y;
        if (p.x == bx && Math.Abs(p.y - by) < bomb.param2)
        {
            for (int i = Math.Min(p.y, by) + 1; i < Math.Max(p.y, by); i++)
                if (Grid.blocking(bx, i))
                {
                    obstr = true;
                    break;
                }
            if (!obstr)
                return true;
        }
        else if (p.y == by && Math.Abs(p.x - bx) < bomb.param2)
        {
            for (int i = Math.Min(p.x, bx) + 1; i < Math.Max(p.x, bx); i++)
                if (Grid.blocking(i, by))
                {
                    obstr = true;
                    break;
                }
            if (!obstr)
                return true;
        }
        return false;
    }

    #region sim
    public void Boom(Entity e)
    {
        if (e.param2 == 0) //it's a bomb's ghost
        {
            return;
        }

        if (e.isExtra && Grid[e.position].param2 > 0)
        {
            // because of <insert reasons>
            // we want to trigger the main bomb first
            // and let IT trigger all the extras
            Boom(Grid[e.position]);
            return;
        }

        int j;
        Entity bomb = e;
        int x = (int)e.xPos;
        int y = (int)e.yPos;
        bomb.param2 = 0;
        if (!e.isExtra)
        {
            Grid[bomb.position] = bomb; //bomb stays on the grid, but we reduce it's range to 0
            copiedGrid[x, y] = new Entity(); // it is not on the new grid, though
        }
        //no need to set the extra's range to 0
        //it can only get triggered if the main bomb on this cell gets triggered

        foreach(Entity player in players)
        {
            if (PointInRange(player.position, e))
            {
                scores[player.owner] = 0;
                players[player.owner].empty = true;
            }
        }
        players[e.owner].param1++;

        if (e.extra < extraBombs.Count) //this bomb has another one underneath
        {
            if (extraBombs[(int)e.extra].param2 > 0)
                Boom(extraBombs[(int)e.extra]);
        }

        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x + j, y) && Grid.blocking(x+j, y))
            {
                Entity en = Grid[x + j, y];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    if (en.param1 == 15) // wall
                        break;
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 1023;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x + j, y] = res; //if we did a boom, it will be empty anyway
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x - j, y) && Grid.blocking(x - j, y))
            {
                Entity en = Grid[x - j, y];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    if (en.param1 == 15) // wall
                        break;
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 1023;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x - j, y] = res;
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y + j) && Grid.blocking(x, y + j))
            {
                Entity en = Grid[x, y + j];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    if (en.param1 == 15)
                        break;
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 1023;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x, y + j] = res;
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y - j) && Grid.blocking(x, y - j))
            {
                Entity en = Grid[x, y - j];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    if (en.param1 == 15)
                        break;
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 1023;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x, y - j] = res;
                break;
            }
        }
    }


    public void DropBomb(int playerID)
    {
        Entity newBomb = new Entity(1, players[playerID].owner, bombTimer, players[playerID].param2, players[playerID].position);

        if (players[playerID].param1 > 0) players[playerID].param1--;
        if (!Grid.free(players[playerID].position))
        {

            Entity theMain = Grid[players[playerID].position];
            newBomb.isExtra = true; // the new bomb is an extra
            newBomb.extra = theMain.extra; // point the new bomb to whatever the main one was pointing to
            extraBombs.Add(newBomb); // add the new bomb to the extra list
            theMain.extra = (uint)(extraBombs.Count - 1); // point the main bomb to the new bomb
            Grid[theMain.position] = theMain; // update the main bomb
        }
        else
        {
            bombs.Add(players[playerID].position);
            newBomb.extra = 1023; //1023 if there's no other bomb on this cell, index on extraBombs if there is one
            Grid[players[playerID].position] = newBomb;
        }
        //only the main bomb exists on the bombs list
    }
    
    public void Move(IEnumerable<Move> moves)
    {
        timer++;

        //all the booms are made to the copied grid
        Grid.CopyTo(copiedGrid);

        //tick the bombs
        for (int i = 0; i < bombs.Count; i++)
        {
            Entity b = Grid[bombs[i]];
            if (b.param1 > 0)
                b.param1--;
            if (b.param2 > 0)
                copiedGrid[b.position] = b;
            if (b.param1 == 0)
            {
                if (b.param2 > 0)
                {
                        Boom(b);
                }
            }
        }
        //tick the extras
        for (int i = 0; i < extraBombs.Count; i++)
        {
            Entity b = extraBombs[i];
            if (b.param1 > 0)
                b.param1--;
            if (b.param1 == 0)
            {
                if (Grid[b.position].param2 > 0)
                {
                        Boom(Grid[b.position]); //both are gonna explode anyway
                                                // but if we trigger only the main bomb
                                                // we have a guarantee of no duplicates, cause it can explode only once
                }
            }
            extraBombs[i] = b;
        }

        // O(n^2), but n is almost always 0, disgustingly rarely bigger than 1
        for (int i = 0; i < extraBombs.Count; i++)
        {
            // an extra can only explode when it's main bomb explodes, and vice-versa
            if (Grid[extraBombs[i].position].param2 == 0)
            {
                for (int j = 0; j < extraBombs.Count; j++)
                {
                    if (extraBombs[j].extra > i && extraBombs[j].extra < extraBombs.Count)
                    {
                        Entity e = extraBombs[j];
                        e.extra--;
                        extraBombs[j] = e; //each pointer pointing to the right of what we're removing
                        // must get lower by 1
                    }
                    if (j > i && copiedGrid[extraBombs[j].position].extra==j)
                    {
                        Entity e = copiedGrid[extraBombs[j].position];
                        e.extra--;
                        copiedGrid[extraBombs[j].position] = e;
                        // if we're moving and are directly above a non-extra bomb
                        // update the non-extra bomb
                    }
                }
                extraBombs.RemoveAt(i);
                i--;
            }
        }
        bombs.RemoveAll(b => Grid[b].param2 == 0);

        //accept the state

        copiedGrid.CopyTo(Grid);

        //consider the moves on the regular grid
        int player = 0;
        foreach (Move move in moves)
        {

                if (move.bomb)
                    DropBomb(player);
            players[player].position = move.destination;
            if (!Grid[players[player].position].empty && Grid[players[player].position].type == 2)
            {
                switch(Grid[players[player].position].param1)
                {
                    case 1:
                        players[player].param2++;
                        upgrades[player]++;
                        break;
                    case 2:
                        players[player].param1++;
                        upgrades[player]++;
                        break;
                }
            }
            player++;
        }
        foreach (Entity p in players)
            if (Grid[p.position].type == 2)
                Grid[p.position] = new Entity();
    }

    public IEnumerable<IEnumerable<Move>> LegalMoves()
    {
        IEnumerable<Point>[] playerMoves = new IEnumerable<Point>[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            
            if (players[i].empty)
            {
                playerMoves[i] = Enumerable.Repeat(players[i].position,1);
            }
            else
            {
                playerMoves[i] = Movements(players[i].position);
            }
        }
        //if (playerMoves[0] == null)
            
        IEnumerable<IEnumerable<Move>> res = playerMoves[0].Select(p => Enumerable.Repeat(new Move(false, p),1));
        if (players[0].param1 > 0 && Grid.free(players[0].position))
            res = res.Concat(playerMoves[0].Select(p => Enumerable.Repeat(new Move(true, p), 1)));

        for (int i = 1; i < playersAmm; i++)
        {
            IEnumerable<Move> myMoves = playerMoves[i].Select(p => new Move(false, p) );
            if (players[i].param1 > 0 && Grid.free(players[i].position))
                myMoves = myMoves.Concat(playerMoves[i].Select(p =>  new Move(true, p) ));

            res = res.SelectMany(a => myMoves, (rest, mine) => rest.Concat(Enumerable.Repeat(mine, 1)));
        }

        return res;

    }

    public int BoxesInRange(Point p, int range)
    {
        int res = 0;
        bool right = true, left = true, up = true, down = true;
        for (int r = 1; r < range; r++)
        {
            if (right && Grid.InBounds(p.x + r, p.y) && Grid.blocking(p.x + r, p.y))
            {
                right = false;
                if (Grid[p.x + r, p.y].type == 3 && Grid[p.x + r, p.y].param1 < 15)
                    res++;
            }
            if (left && Grid.InBounds(p.x - r, p.y) && Grid.blocking(p.x - r, p.y))
            {
                left = false;
                if (Grid[p.x - r, p.y].type == 3 && Grid[p.x - r, p.y].param1 < 15)
                    res++;
            }
            if (up && Grid.InBounds(p.x, p.y - r) && Grid.blocking(p.x, p.y - r))
            {
                up = false;
                if (Grid[p.x, p.y - r].type == 3 && Grid[p.x, p.y - r].param1 < 15)
                    res++;
            }
            if (down && Grid.InBounds(p.x, p.y + r) && Grid.blocking(p.x, p.y + r))
            {
                down = false;
                if (Grid[p.x, p.y + r].type == 3 && Grid[p.x, p.y + r].param1 < 15)
                    res++;
            }
        }
        return res;
    }

    public IEnumerable<Point> Movements(Point point)
    {
        return point.Neighbours().
            Where(p => Grid.free(p)).Concat(Enumerable.Repeat(point, 1));
    }



    public void RandomMove()
    {
        
        Move[] moves = new Move[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            if (players[i].empty)
            {
                moves[i].destination = players[i].position;
            }
            else
            {
                IEnumerable<Point> dests = Movements(players[i].position);
                dests = dests.Where(p =>
                   {
                       if (Movements(p).Count() < 2)
                           return false;
                       foreach (Point b in bombs)
                           if (Grid[b].param1 == 2 && PointInRange(p, Grid[b]))
                               return false;
                       foreach (Entity b in extraBombs)
                           if (b.param1 == 2 && PointInRange(p, b))
                               return false;

                       return true;
                   });
                if (dests.Count() == 0)
                {
                    moves[i].destination = players[i].position;
                    //Console.Error.WriteLine($"no moves for {i}");
                }
                else
                {
                    //Console.Error.WriteLine($"Moves for {i}:" );
                    //foreach (Point p in dests)
                    //    Console.Error.WriteLine(p);
                    int m = MCT.random.Next(dests.Count());
                    if (m == dests.Count() - 1)
                        m = MCT.random.Next(dests.Count());
                    if (m == dests.Count() - 1)
                        m = MCT.random.Next(dests.Count());
                    moves[i].destination = dests.ElementAt(m);

                }
                if (MCT.random.Next() % 2 == 0  
                    && players[i].param1 > 0 
                    && Grid.free(players[i].position)
                    && BoxesInRange(players[i].position, (int)players[i].param2) > 0
                    && Movements(moves[i].destination).Count() > 2)
                {

                    moves[i].bomb = true;

                }
                else
                    moves[i].bomb = false;
            }
        }
        MCT.whomoves = 1;
        Move(moves);
    }
    #endregion

    // board.Clear(), followed by board.Grid.UpdateRow() and board.UpdateEntity()
    // load a complete gamestate to the board
    #region utils
    public void Clear()
    {
       // Move[] moves = new Move[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            //moves[i].destination = players[i].position;
           // moves[i].bomb = false;
            guessedMoves[i].bomb = false;
        }
        Grid.CopyTo(copiedGrid);
        foreach(Point bomb in bombs)
            if (Grid[bomb].param1 == 1 && Grid[bomb].param2 > 0)
            {
                Boom(Grid[bomb]);
            }
        foreach (Entity bomb in extraBombs)
            if (bomb.param1 == 1 && bomb.param2 > 0)
            {
                Boom(bomb);
            }
        copiedGrid.CopyTo(Grid);
        bombs.Clear();
        extraBombs.Clear();
        this.timer++;
    }

    public void UpdateEntity(Entity e)
    {

        if (e.type == 0)
        {
            guessedMoves[e.owner].destination = e.position;
            if (!Grid[e.position].empty && Grid[e.position].type == 2)
                upgrades[e.owner]++;

            players[e.owner] = e;
        }
        else
        {
            if (e.type == 1)
            {
                Console.Error.WriteLine("bomb!!!!");
                if (e.param1 == 8)
                {
                    guessedMoves[e.owner].bomb = true;
                }
                bombs.Add(e.position);
            }
            else
            { 
                if (e.type == 2)
                {
                    e.owner = 0;
                    e.param2 = 0;
                }
            }
            copiedGrid[e.position] = e;
        }

    }

    
    public static bool operator ==(Board b1, Board b2)
    {
        if (b1.timer != b2.timer)
        {
            Console.Error.WriteLine($"Timers {b1.timer} != {b2.timer}");
        }
        if (b1.bombs.Count != b2.bombs.Count)
        {
            Console.Error.WriteLine($"bc {b1.bombs.Count} != {b2.bombs.Count}");
            return false;
        }
        for (int i = 0; i < b1.bombs.Count; i++)
        {
            if (b1.bombs[i] != b2.bombs[i])
            {
                Console.Error.WriteLine($"b {b1.bombs[i]} != {b2.bombs[i]}");
                return false;
            }
        }
        for (int i = 0; i < b1.playersAmm; i++)
        {
            if (b1.players[i] != b2.players[i])
            {
                Console.Error.WriteLine($"p {b1.players[i]} != {b2.players[i]}");
                return false;
            }
            if (b1.upgrades[i] != b2.upgrades[i])
            {
                Console.Error.WriteLine($"u {b1.upgrades[i]} != {b2.upgrades[i]}");
                return false;
            }
            if (b1.scores[i] != b2.scores[i])
            {
                Console.Error.WriteLine($"s {b1.scores[i]} != {b2.scores[i]}");
                return false;
            }
        }
        if (b1.extraBombs.Count != b2.extraBombs.Count)
        {
            Console.Error.WriteLine($"exc {b1.extraBombs.Count} != {b2.extraBombs.Count}");
            return false;
        }
        for (int i = 0; i < b1.extraBombs.Count; i++)
        {
            if (b1.extraBombs[i] != b2.extraBombs[i])
                if (b1.bombs[i] != b2.bombs[i])
                {
                    Console.Error.WriteLine($"ex {b1.extraBombs[i]} != {b2.extraBombs[i]}");
                    return false;
                }
        }
        for (int y = 0; y < b1.Grid.height; y++)
            for (int x = 0; x < b1.Grid.width; x++)
                if (b1.Grid[x, y] != b2.Grid[x, y])
                {
                    Console.Error.WriteLine($"g at {x},{y} {b1.Grid[x,y]} != {b2.Grid[x,y]}");
                    return false;
                }

        return true;
        
    }

    public static bool operator !=(Board b1, Board b2)
    {
        return !(b1 == b2);
    }

    public override String ToString()
    {
        Grid g = new Grid(Grid.width, Grid.height);
        Grid.CopyTo(g);
        StringBuilder res = new StringBuilder();
        res.AppendLine($"TIME: {timer}");
       
        foreach (Point bomb in bombs)
        {
            res.Append(Grid[bomb]);
            res.AppendLine();
        }
        foreach (Entity bomb in extraBombs)
        {
            res.Append("EXTRA: ");
            res.Append(bomb);
            res.AppendLine();
        }
        foreach (Entity player in players)
        {
            res.Append(player.ToString());
            res.Append($" SCORE: {scores[player.owner]}");
            res.Append($" U: {upgrades[player.owner]}");

            res.AppendLine();
        }
        res.Append("\n\n");
        res.Append(g.ToString());
        return res.ToString();
    }
    #endregion
}

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/




class Player
{

    static void Main(string[] args)
    {
        DateTime deadline = DateTime.Now.AddMilliseconds(980);
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        uint width = uint.Parse(inputs[0]);
        uint height = uint.Parse(inputs[1]);
        int myId = int.Parse(inputs[2]);

        Board board = new Board(width, height);

        //first turn
        for (int i = 0; i < height; i++)
        {
            string row = Console.ReadLine();
            foreach (char c in row)
                if (c != '.')
                    board.remainingBoxes++;
            board.copiedGrid.UpdateRow(i, row);
        }

        int entities = int.Parse(Console.ReadLine());

        List<Entity> players = new List<Entity>();
        for (int i = 0; i < entities; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            Entity e = new Entity();
            e.empty = false;
            e.extra = 1023;
            e.isExtra = false; e.type = uint.Parse(inputs[0]);
            e.owner = uint.Parse(inputs[1]);
            e.xPos = uint.Parse(inputs[2]);
            e.yPos = uint.Parse(inputs[3]);
            e.param1 = uint.Parse(inputs[4]);
            e.param2 = uint.Parse(inputs[5]);
            Console.Error.WriteLine($"Got entity {e}");
            if (e.type == 0)
                players.Add(e);
            else
                board.UpdateEntity(e);
        }
        board.SetPlayersAmm(players.Count);
        foreach (Entity player in players)
            board.UpdateEntity(player);
        board.copiedGrid.CopyTo(board.Grid);


       // for (int i = 0; i < 40; i++)
       // {
       //     Console.Error.WriteLine(board);
       //     board.RandomMove();
       // }

        MCT mct = new MCT(board, myId);

        Console.Error.WriteLine(board);
        Console.WriteLine(mct.Run(deadline));

        // game loop
        while (true)
        {
            deadline = DateTime.Now.AddMilliseconds(95);
            board.Clear();
            for (int i = 0; i < height; i++)
            {
                string row = Console.ReadLine();
                board.copiedGrid.UpdateRow(i, row);
            }
            entities = int.Parse(Console.ReadLine());
            for (int i = 0; i < entities; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                Entity e = new Entity();
                e.empty = false;
                e.extra = 1023;
                e.isExtra = false;
                e.type = uint.Parse(inputs[0]);
                e.owner = uint.Parse(inputs[1]);
                e.xPos = uint.Parse(inputs[2]);
                e.yPos = uint.Parse(inputs[3]);
                e.param1 = uint.Parse(inputs[4]);
                e.param2 = uint.Parse(inputs[5]);
                board.UpdateEntity(e);
            }
            board.copiedGrid.CopyTo(board.Grid);
            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            mct.Reuse(board.guessedMoves);
            Console.Error.WriteLine($"Time: {board.timer}");
            Console.WriteLine(mct.Run(deadline));
            Console.Error.WriteLine($"{(deadline.AddMilliseconds(5) - DateTime.Now).Milliseconds}ms until deadline");


        }
    }

}


class MCT
{
    public static int whomoves = -1;
    MCTNode root;
    public static readonly Random random = new Random();
    public static readonly float explorationRate = 20;
    Board board; //represents the state of root node
    int MyPlayerId;


    public MCT(Board board, int myid)
    {
        this.board = board;
        MyPlayerId = myid;
        root = new MCTNode(board.Copy(), null);
    }

    public void Reuse(Move[] moves)
    {
        int c = 0;
        for (int i = 0; i < root.Children.Length; i++)
        {
            MCTNode child = root.Children[i];
            int m = 0;
            bool thisIsIt = true;
            foreach (Move move in root.Moves[i])
            {
                if (move != moves[m])
                {
                    thisIsIt = false;
                    break;
                }
                m++;
            }
            if (thisIsIt)
            {
                root = child;
                if (root == null || root.Moves == null)
                {
                    Console.Error.WriteLine("Had to make a new tree");
                    root = new MCTNode(board.Copy(), null);
                }
                else
                {

                    root.Parent = null;
                }
                return;
            }
            c++;
        }
        Console.Error.WriteLine("Nothing to reuse, wth?");
        Console.Error.WriteLine($"main: {board}");

        throw new Exception("nothing to reuse");
    }

    public Move Run(DateTime deadline)
    {
        if (DateTime.Now >= deadline)
        {
            Console.Error.WriteLine("srsly? Time gone before I started");
        }

        while (DateTime.Now < deadline)
        {
            Board curBoard = board.Copy();
            MCTNode vl = TreePolicy(root, curBoard);
            // after TreePolicy curBoard represents the state
            // of the returned node
            float[] scores;
            if (vl.Moves != null)
            {
                scores = DefaultPolicy(curBoard);
            }
            else
            {

                scores = new float[board.playersAmm];
                for (int i = 0; i < scores.Length; i++)
                    scores[i] = vl.Parent.MeanScoreOfPlayer(i);
            }
            BackUp(vl, scores);
        }
        if (root.expansion == 0)
        {
            Console.Error.WriteLine("Couldn't even search!");
            return root.Moves[0].ElementAt(MyPlayerId);
        }

        Console.Error.WriteLine($"Let's see who's the winner, root pulled {root.TimesPulled} times, has {root.expansion} children!");

        Move m = root.PickMove(MyPlayerId);
        if (m.bomb)
        {
            Console.Error.WriteLine($"it has {board.BoxesInRange(board.players[MyPlayerId].position, (int)board.players[MyPlayerId].param2)}");
        }
        return m;
    }

    void BackUp(MCTNode v, float[] scores)
    {
        while (v != null)
        {
            v.TimesPulled++;
            bool killed = false;
            for (int i = 0; i < scores.Length; i++)
            {

                if (scores[i] < 0 && !killed)
                {
                    v.kills++;
                    killed = true;
                    break;
                }
            }
            if (!killed)
                for (int i = 0; i < scores.Length; i++)
                {
                    v.scores[i] += scores[i];
                }

            v = v.Parent;
        }
    }

    MCTNode TreePolicy(MCTNode v, Board curBoard)
    {
        MCTNode cur = v;

        while (!curBoard.Terminal) //"v is not terminal"
        {
            if (!cur.FullyExpanded)
            {
                return cur.Expand(curBoard);
            }
            else
            {
                int winner = cur.BestChild(MyPlayerId);
                whomoves = 2;
                curBoard.Move(cur.Moves[winner]);
                cur = cur.Children[winner];
            }
        }
        return cur;
    }

    int d = 0;
    float[] DefaultPolicy(Board curBoard)
    {
        //Console.Error.WriteLine($"SIM at board {curBoard}");
        d = 0;
        int remBoxes = curBoard.remainingBoxes;
        int time = curBoard.timer;
        float[] scores = new float[curBoard.playersAmm];
        for (int i = 0; i < curBoard.playersAmm; i++)
        {
            if (curBoard.players[i].empty)
            {
                scores[i] = -100;
            }
            else
            {
                scores[i] += curBoard.scores[i] * 0.1f;
                scores[i] += (curBoard.Movements(curBoard.players[i].position).Count() - 1) * 3;
                double b = 0;
                Point p = curBoard.players[i].position;
                for (int r = 1; r < 4; r++)
                {
                    for (int a = 0; a <= r; a++)
                    {
                        int x = p.x + a,
                            y = p.y + (r - a);
                        if (curBoard.Grid.InBounds(x, y) && !curBoard.Grid[x, y].empty)
                        {

                            if (curBoard.players[i].param1 > 0 && curBoard.Grid[x, y].type == 3 && curBoard.Grid[x, y].param1 < 15)
                                b += 0.5 / (r * r + 2);
                            else if (curBoard.Grid[x, y].type == 2)
                                b += 3 / (r * r + 1);
                        }
                        x = p.x + a;
                        y = p.y - (r - a);
                        if (curBoard.Grid.InBounds(x, y) && !curBoard.Grid[x, y].empty)
                        {

                            if (curBoard.players[i].param1 > 0 && curBoard.Grid[x, y].type == 3 && curBoard.Grid[x, y].param1 < 15)
                                b += 0.5 / (r * r + 2);
                            else if (curBoard.Grid[x, y].type == 2)
                                b += 3 / (r * r + 1);
                        }
                        x = p.x - a;
                        y = p.y + (r - a);
                        if (curBoard.Grid.InBounds(x, y) && !curBoard.Grid[x, y].empty)
                        {

                            if (curBoard.players[i].param1 > 0 && curBoard.Grid[x, y].type == 3 && curBoard.Grid[x, y].param1 < 15)
                                b += 0.5 / (r * r + 2);
                            else if (curBoard.Grid[x, y].type == 2)
                                b += 3 / (r * r + 1);
                        }
                        x = p.x - a;
                        y = p.y - (r - a);
                        if (curBoard.Grid.InBounds(x, y) && !curBoard.Grid[x, y].empty)
                        {

                            if (curBoard.players[i].param1 > 0 && curBoard.Grid[x, y].type == 3 && curBoard.Grid[x, y].param1 < 15)
                                b += 0.5 / (r * r + 2);
                            else if (curBoard.Grid[x, y].type == 2)
                                b += 3 / (r * r + 1);
                        }
                    }
                }
                //Console.Error.WriteLine($"B value of {i} = {b} at time {curBoard.timer} ");
                scores[i] += (float)b;
                scores[i] += curBoard.upgrades[i] * 0.8f;
            }
        }

        // -----------------------------------------
        // SIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIM!
        //------------------------------------------
        while (curBoard.remainingBoxes > remBoxes * 0.8 && !curBoard.Terminal && curBoard.timer - time < 9)
        {
            curBoard.RandomMove();
            d++;
        }

        for (int i = 0; i < curBoard.playersAmm; i++)
        {
            if (curBoard.players[i].empty && scores[i] >= 0)
            {
                //Console.Error.Write($"sim kills {i}");
                scores[i] = -0.001f;
            }
            else
            {
                scores[i] += curBoard.upgrades[i] * 0.4f;
                scores[i] += curBoard.scores[i] * 0.05f;
            }
        }
        //foreach (float s in scores)
        //    Console.Error.Write($"[{s}]");
        //Console.Error.WriteLine();
        //Console.Error.WriteLine($"after {d} steps Returning scores {scores[0]}, {scores[1]}");
        return scores;
    }

}

class MCTNode
{
    public int kills = 0;
    public IEnumerable<Move>[] Moves;
    public int ChildrenCount;
    public MCTNode[] Children;
    public MCTNode Parent;
    public bool FullyExpanded { get { return expansion == ChildrenCount; } }
    public int TimesPulled;
    public int[] MoveSenses;
    public bool lethal { get { return kills == TimesPulled; } }

    //mean score of a single player in this Node's state
    public float MeanScoreOfPlayer(int which)
    {
        if (TimesPulled != kills)
            return ((float)scores[which]) / (TimesPulled - kills);
        else return 0;
    }

    public float[] scores;
    public int expansion;

    public Move PickMove(int playerID)
    {
        int last = -1;
        Move[] possibilities = new Move[10];
        float[] finalRatings = new float[10];
        int[] occurences = new int[10];
        float[] kills = new float[10];
        for (int i = 0; i < ChildrenCount; i++)
        {
            if (MoveSenses[i] > 0 && Children[i] != null)
            {
                Move m = Moves[i].ElementAt(playerID);
                bool found = false;
                for (int j = 0; j <= last; j++)
                    if (possibilities[j] == m)
                    {
                        found = true;
                        if (!Children[i].lethal)
                            finalRatings[j] += Children[i].scores[playerID];
                        occurences[j] += Children[i].TimesPulled - Children[i].kills;
                        kills[j] += Children[i].kills;

                        break;
                    }
                if (!found)
                {
                    //if (possibilities.Contains(m))
                    //    Console.Error.WriteLine($"I'm disapppoint, {m} already in");
                    last++;
                    possibilities[last] = m;
                    occurences[last] = Children[i].TimesPulled - Children[i].kills;
                    if (!Children[i].lethal)
                        finalRatings[last] = Children[i].scores[playerID];
                    else
                        finalRatings[last] = 0;
                    kills[last] += Children[i].kills;
                    //Console.Error.Write($"{m} at {i} = {RateChild(i, playerID)}  ");
                    //for (int x = 0; x < scores.Length; x++)
                    //    Console.Error.Write($"[{Children[i].MeanScoreOfPlayer(x)}]");
                }
            }
        }
        int maxi = -1;
        float max = -1000;
        for (int i = 0; i <= last; i++)
        {
            float rating = finalRatings[i] / occurences[i];
            if (occurences[i] == 0)
                rating = -66666666;
            Console.Error.WriteLine($"{possibilities[i]} is rated {rating}, killed {kills[i]}, occured {occurences[i]}");
            if (rating > max)
            {
                max = rating;
                maxi = i;
            }
        }
        if (maxi < 0)
        {
            Console.Error.WriteLine("We're dead anyway");
            maxi = 0; //we're dead anyway
        }

        return possibilities[maxi];
    }

    public MCTNode Expand(Board board)
    {

        board.Move(Moves[expansion]); //state(newChild) = f(state(this), move);

        Children[expansion] = new MCTNode(board, this, MoveSenses[expansion] == 0);
        expansion++;

        return Children[expansion - 1];
    }


    public float RateChild(int i, int playerID)
    {
        float myScore = Children[i].MeanScoreOfPlayer(playerID);
        //float theirScore = 0;
        float maxEnemy = float.MinValue;
        //float totalScore = 0;
        for (int j = 0; j < scores.Length; j++)
        {

            //totalScore += Children[i].MeanScoreOfPlayer(j);
            if (j != playerID)
            {
                //theirScore += Children[i].MeanScoreOfPlayer(j);
                if (Children[i].MeanScoreOfPlayer(j) > maxEnemy)
                    maxEnemy = Children[i].MeanScoreOfPlayer(j);
            }
        }
        // theirScore /= scores.Length - 1;
        // if (theirScore > 0 && totalScore > 0)
        //     return (myScore - maxEnemy) * (1 + theirScore / totalScore);

        return (myScore - maxEnemy);
    }

    public int BestChild(int playerID)
    {
        int theOne = -1;
        float bestScore = int.MinValue;
        for (int i = 0; i < ChildrenCount; i++)
        {
            if (Children[i] != null)
            {
                float score;
                if (MoveSenses[i] == 0)
                    score = -5000;
                else
                {
                    score = 100 + RateChild(i, playerID);
                    score += MCT.explorationRate * (float)Math.Sqrt(2 * Math.Log(TimesPulled) / Children[i].TimesPulled);
                    score *= 1 + (float)MoveSenses[i] / 4;
                }
                if (score > bestScore)
                {
                    bestScore = score;
                    theOne = i;
                }
            }
        }
        return theOne;
    }

    public MCTNode(Board board, MCTNode par, bool trash = false)
    {
        if (trash)
        {
            Parent = par;
            scores = new float[board.playersAmm];
            return;
        }
        Moves = board.LegalMoves().OrderBy(x => MCT.random.Next()).ToArray();
        MoveSenses = new int[Moves.Count()];
        for (int i = 0; i < Moves.Count(); i++)
        {
            bool freeze = false;
            MoveSenses[i] = 4096;
            int player = 0;
            foreach (Move m in Moves[i])
            {
                if (m.bomb)
                    MoveSenses[i] = Math.Min(MoveSenses[i], board.BoxesInRange(board.players[player].position, (int)board.players[player].param2));
                if (m.destination == board.players[player].position)
                {
                    freeze = true;
                }
                player++;

            }
            if (MoveSenses[i] == 4096)
                MoveSenses[i] = 1;
            if (!freeze)
                MoveSenses[i] *= 8;
        }
        ChildrenCount = Moves.Length;

        Children = new MCTNode[ChildrenCount];
        Parent = par;
        TimesPulled = 0;
        expansion = 0;
        scores = new float[board.playersAmm];
    }
}

struct Entity : IEquatable<Entity>
{
    private uint _val;

    public Point position
    {
        get
        {
            return new Point(xPos, yPos);
        }
        set
        {
            yPos = (uint)value.y;
            xPos = (uint)value.x;
        }

    }

    // get: << (31-left) >> (31 - left + right)
    // set: << right

    public bool Equals(Entity e)
    {
        return e.empty && this.empty ||_val == e._val;
    }

    public static bool operator ==(Entity e1, Entity e2)
    {
        return (e1.Equals(e2));
    }

    public static bool operator !=(Entity e1, Entity e2)
    {
        return (!e1.Equals(e2));
    }

    public bool isExtra //0-1, bit 31
    {   //1 means it's an extra
        get
        {
            return 1 == (_val >> 31);
        }
        set
        {
            if (value)
                _val |= (uint)1 << 31;
            else
                _val &= ~((uint)1 << 31);

        }
    }

    public uint extra // 0-1023 bits 30 to 21
    {
        get
        {
            return (_val << 1) >> 22;
        }
        set
        {
            if (value > 1023)
                throw new Exception("extra is 0-1023");
            _val &= ~((uint)1023 << 21);
            _val |= value << 21;
        }
    }

    public bool empty //0-1, bit 20
    {
        //0 is empty
        get
        {
            return 0 == ((_val << 11) >> 31);
        }
        set
        {
            if (value)
                _val &= ~(uint)(1 << 20);
            else
                _val |= (1 << 20);
        }
    }
   
    public uint yPos // 0-15, bits 19 to 16
    {
        get
        {
            return (_val << 12) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("ypos is 0-15");
            _val &= ~(uint)(15 << 16);
            _val |= value << 16;
        }
    }
    public uint xPos // 0-15, bits 15 to 12
    {
        get
        {
            return (_val << 16) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("xpos is 0-15");
            _val &= ~(uint)(15 << 12);
            _val |= value << 12;
        }
    }

    /// <summary>
    /// 0 is player, 1 is bomb, 2 is item, 3 is box
    /// </summary>
    ///
    public uint type // 0-3, bits 11 to 10
    {
        get
        {
            return (_val << 20) >> 30;
        }
        set
        {
            if (value > 3)
                throw new Exception("type is 0-3");
            _val &= ~(uint)(3 << 10);
            _val |= value << 10;
        }
    }

    /// <summary>
    /// id of the player/player who put the bomb
    /// </summary>
    public uint owner // 0-3, bits 9 to 8
    {
        get
        {
            return (_val << 22) >> 30;
        }
        set
        {
            if (value > 3)
                throw new Exception("owner is 0-1");
            _val &= ~(uint)(3 << 8);
            _val |= value << 8;
        }
    }

    /// <summary>
    /// bombs remaining / bomb timer / item type
    /// </summary>
    public uint param1 // 0-15, bits 7 to 4
    {
        get
        {
            return (_val << 24) >> 28;
        }
        set
        {
            if (value > 15)
            {
                throw new Exception($"param1 is 0-15, not {value} for {this}");
            }
            _val &= ~(uint)(15 << 4);
            _val |= value << 4;
        }
    }

    /// <summary>
    /// explosion range
    /// </summary>
    public uint param2 //0-15, bits 3 to 0
    {
        get
        {
            return (_val << 28) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("param2 is 0-15");
            _val &= ~(uint)15;
            _val |= value;
        }
    }

    public Entity(uint t, uint own, uint p1, uint p2, Point position)
    {
        _val = 0;
        this.position = position;
        type = t; owner = own; param1 = p1; param2 = p2;
        empty = false;
    }


    public override string ToString()
    {

        String t = "";
        if (empty)
            t = "(empty)";
        if (isExtra)
            t += "(extra)";
        if (extra != 1023)
            t += $"(ptr {extra})";
        switch(type)
        {
            case 0:
                t+= "player";
                break;
            case 1:
                t+= "bomb";
                break;
            case 2:
                t+= "item";
                break;
            case 3:
                t += "box";
                break;
        }
        return $"{t} of team {owner} at {position}, p1 {param1}, p2 {param2}";
    }
}

struct Point
{
    public int x;
    public int y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    public Point(uint x, uint y)
    {
        this.x = (int)x;
        this.y = (int)y;
    }

    public IEnumerable<Point> Neighbours()
    {
        yield return new Point(x - 1, y);
        yield return new Point(x + 1, y);
        yield return new Point(x, y - 1);
        yield return new Point(x, y + 1);
    }

    public override string ToString()
    {
        return $"({x},{y})";
    }

    public static bool operator !=(Point p1, Point p2)
    {
        return (p1.x != p2.x || p1.y != p2.y);
    }

    public static bool operator ==(Point p1, Point p2)
    {
        return (p1.x == p2.x && p1.y == p2.y);
    }

}

struct Move
{
    public bool bomb;
    public Point destination;

    public Move(bool b, Point p)
    {
        bomb = b;
        destination = p;
    }

    public static bool operator !=(Move m1, Move m2)
    {
        return (m1.bomb != m2.bomb || m1.destination != m2.destination);
    }

    public static bool operator ==(Move m1, Move m2)
    {
        return (m1.bomb == m2.bomb && m1.destination == m2.destination);
    }

    public override string ToString()
    {
        String comm = bomb ? "BOMB" : "MOVE";
        return $"{comm} {destination.x} {destination.y}";
    }
}

class Grid
{
    Entity[,] ents;
    public uint height { get; private set; }
    public uint width { get; private set; }

    /// <summary>
    /// true if a player can move on this cell, false otherwise
    /// </summary>
    public bool free(int x, int y)
    {
        // false if cell out of bounds, is a box, or is a bomb
        return (InBounds(x, y) && (ents[y,x].empty || (ents[y, x].type != 3 && ents[y, x].type != 1)));
    }
    public bool free(Point p)
    {
        // false if cell out of bounds, is a box, or is a bomb
        return (InBounds(p) && (ents[p.y, p.x].empty || (ents[p.y, p.x].type != 3 && ents[p.y, p.x].type != 1)));
    }

    /// <summary>
    /// true if this cell stops a bomb's explosion
    /// </summary>
    public bool blocking(int x, int y)
    {
        // true if cell out of bounds, is a box, an item, or a bomb
        return (ents[y, x].type != 0 && !ents[y,x].empty);
    }
    public bool blocking(Point p)
    {
        // true if cell out of bounds, is a box, or is a bomb
        return (ents[p.y, p.x].type != 0);
    }

    public Entity this[Point p]
    {
        get
        {
            return ents[p.y, p.x];
        }
        set
        {
            ents[p.y, p.x] = value;
        }
    }

    public Entity this[int x, int y]
    {
        get
        {
            if (!InBounds(x, y))
                throw new Exception("blah");
            return ents[y, x];
        }
        set
        {
            ents[y, x] = value;
        }
    }

    public override String ToString()
    {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < height; i++)
        {
            for (int j = 0; j < width; j++)
            {
                if (this[j, i].empty)
                    builder.Append(".");
                else if (this[j, i].type == 3)
                {
                    if (this[j, i].param1 < 15)
                        builder.Append(this[j, i].param1);
                    else builder.Append("X");
                }
                else if (this[j, i].type == 1)
                {
                    if (this[j, i].param2 == 0)
                        builder.Append("?");
                    else
                        builder.Append("b");
                }
                else if (this[j, i].type == 2)
                {
                    if (this[j, i].param1 == 1)
                        builder.Append("*");
                    else if (this[j, i].param1 == 2)
                        builder.Append("+");
                    else
                        builder.Append("?");
                }
                else if (this[j, i].type == 0)
                    builder.Append("?");
               
            }
            builder.AppendLine();
        }
        return builder.ToString();
    }

    public bool InBounds(Point p)
    {
        return (p.x >= 0 && p.x < width && p.y >= 0 && p.y < height);
    }
    public bool InBounds(int x, int y)
    {
        return (x >= 0 && x < width && y >= 0 && y < height);
    }
    public bool InBounds(uint x, uint y)
    {
        return (x < width && y < height);
    }
    public Grid(uint width, uint height)
    {
        this.width = width;
        this.height = height;
        ents = new Entity[height,width];
    }
    public void CopyTo(Grid grid)
    {
        
        Array.Copy(ents, grid.ents, width * height);
    }

    public void UpdateRow(int which, String row)
    {
        for (int i = 0; i < row.Length; i++)
        {
            Entity t = new Entity();
            if (row[i] == '.')
                t.empty = true;
            else
            {
                t.empty = false;
                t.type = 3;
                int item = (row[i] - 48);
                if (item > 15)
                    item = 15;
                t.param1 = (uint)item;
                t.xPos = (uint)i;
                t.yPos = (uint)which;
                t.owner = 0;
                t.extra = 1023;
                t.isExtra = false;
                t.param2 = 0;
            }
            ents[which, i] = t;
        }

    }
}
