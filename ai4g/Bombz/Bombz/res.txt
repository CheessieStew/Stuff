using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Collections;



class Board
{
    public static readonly uint bombTimer = 8;

    public Grid Grid;
    public int playersAmm;
    public int timer;

    public Move[] guessedMoves;
    public List<Point> bombs;
    public List<Entity> extraBombs;
    public Entity[] players;
    public int[] scores;
    public int[] upgrades;
    public int remainingBoxes;
    public bool Terminal
    {
        get { return remainingBoxes == 0; }
    }

    public Grid copiedGrid;

    public Board(uint width, uint height, int playersAmm)
    {
        Grid = new Grid(width, height);
        copiedGrid = new Grid(width, height);
        this.playersAmm = playersAmm;

        bombs = new List<Point>();
        extraBombs = new List<Entity>();
        players = new Entity[playersAmm];
        upgrades = new int[playersAmm];
        scores = new int[playersAmm];

        for (int i = 0; i < playersAmm; i++)
            scores[i] = 0;

        guessedMoves = new Move[playersAmm];
        remainingBoxes = 0;
        timer = 0;
    }

    public Board Copy()
    {
        Board res = new Board(Grid.width, Grid.height, playersAmm);
        Grid.CopyTo(res.Grid);
        res.bombs = bombs.ConvertAll(b => b);
        res.extraBombs = extraBombs.ConvertAll(b => b);

        upgrades.CopyTo(res.upgrades, 0);
        players.CopyTo(res.players, 0);
        scores.CopyTo(res.scores, 0);
        res.remainingBoxes = remainingBoxes;
        res.timer = timer;
        return res;
    }


    #region sim
    public void Boom(Entity e)
    {
        if (e.param2 == 0) //it's a bomb's ghost
        {
            Console.Error.WriteLine("GHOST TRIGGERED");
            return;
        }
        if (e.type != 1)
            throw new Exception($"can't boom {e}");
        if (e.isExtra && Grid[e.position].param2 > 0)
        {
            // because of <insert reasons>
            // we want to trigger the main bomb first
            // and let IT trigger all the extras
            Boom(Grid[e.position]);
            return;
        }

        int j;
        Entity bomb = e;
        int x = (int)e.xPos;
        int y = (int)e.yPos;
        bomb.param2 = 0;
        if (!e.isExtra)
        {
            Grid[bomb.position] = bomb; //bomb stays on the grid, but we reduce it's range to 0
            copiedGrid[x, y] = new Entity(); // it is not on the new grid, though
        }
        //no need to set the extra's range to 0
        //it can only get triggered if the main bomb on this cell gets triggered

        if (copiedGrid[x, y].empty != true)
            throw new Exception("GOTCHA");
        players[e.owner].param1++;

        if (e.extra < extraBombs.Count) //this bomb has another one underneath
        {
            if (extraBombs[(int)e.extra].param2 > 0)
                Boom(extraBombs[(int)e.extra]);
        }

        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x + j, y) && Grid.blocking(x+j, y))
            {
                Entity en = Grid[x + j, y];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        if (res.position != new Point(x + j, y))
                            throw new Exception($"wow! {res.position} instead of {x + j}, {y}");
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 2047;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x + j, y] = res; //if we did a boom, it will be empty anyway
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x - j, y) && Grid.blocking(x - j, y))
            {
                Entity en = Grid[x - j, y];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 2047;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x - j, y] = res;
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y + j) && Grid.blocking(x, y + j))
            {
                Entity en = Grid[x, y + j];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 2047;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x, y + j] = res;
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y - j) && Grid.blocking(x, y - j))
            {
                Entity en = Grid[x, y - j];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.isExtra = false;
                        res.extra = 2047;
                        res.type = 2;
                        res.param2 = 0;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x, y - j] = res;
                break;
            }
        }
    }

    /*
    public void FalseBoom(Entity e)
    {
        if (e.param2 == 0) //it's a bomb's ghost
        {
            Console.Error.WriteLine("GHOST TRIGGERED");
            return;
        }
        if (e.type != 1)
            throw new Exception($"can't boom {e}");
        if (e.isExtra && Grid[e.position].param2 > 0)
        {
            // because of <insert reasons>
            // we want to trigger the main bomb first
            // and let IT trigger all the extras
            FalseBoom(Grid[e.position]);
            return;
        }

        int j;
        Entity bomb = e;
        int x = (int)e.xPos;
        int y = (int)e.yPos;
        bomb.param2 = 0;
        if (!e.isExtra)
        {
            Grid[bomb.position] = bomb; //bomb stays on the grid, but we reduce it's range to 0
        }

        if (e.extra < extraBombs.Count) //this bomb has another one underneath
        {
            if (extraBombs[(int)e.extra].param2 > 0)
                FalseBoom(extraBombs[(int)e.extra]);
        }

        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x + j, y) && Grid.blocking(x + j, y))
            {
                Entity en = Grid[x + j, y];
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    FalseBoom(en);
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x - j, y) && Grid.blocking(x - j, y))
            {
                Entity en = Grid[x - j, y];
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;

                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    FalseBoom(en);

                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y + j) && Grid.blocking(x, y + j))
            {
                Entity en = Grid[x, y + j];
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    FalseBoom(en);
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y - j) && Grid.blocking(x, y - j))
            {
                Entity en = Grid[x, y - j];
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    FalseBoom(en);
                break;
            }
        }
    }
    */

    public void DropBomb(int playerID)
    {
        Entity newBomb = new Entity(1, players[playerID].owner, bombTimer, players[playerID].param2, players[playerID].position);
        if (newBomb.param2 == 0)
            Console.Error.WriteLine($"{newBomb} should not exist");
        if (players[playerID].param1 > 0) players[playerID].param1--;
        if (!Grid.free(players[playerID].position))
        {
            if (Grid[players[playerID].position].type != 1)
                throw new Exception("Throwing bomb on top of not-bomb");
            if (Grid[players[playerID].position].param1 != 8)
                throw new Exception("Throwing bomb on top of not-fresh bomb");
            Entity theMain = Grid[players[playerID].position];
            newBomb.isExtra = true; // the new bomb is an extra
            newBomb.extra = theMain.extra; // point the new bomb to whatever the main one was pointing to
            extraBombs.Add(newBomb); // add the new bomb to the extra list
            theMain.extra = (uint)(extraBombs.Count - 1); // point the main bomb to the new bomb
            Grid[theMain.position] = theMain; // update the main bomb
        }
        else
        {
            bombs.Add(players[playerID].position);
            newBomb.extra = 2047; //2047 if there's no other bomb on this cell, index on extraBombs if there is one
            Grid[players[playerID].position] = newBomb;
        }
        //only the main bomb exists on the bombs list
    }

    public bool Legal(IEnumerable<Move> moves)
    {
        int i = 0;
        foreach (var move in moves)
        {
            if ((!Grid.free(move.destination) && move.destination != players[i].position) || move.bomb && (players[i].param1 == 0 || (!Grid.free(players[i].position) && Grid[players[i].position].param1 != 8)))
            {
                Console.Error.WriteLine($"Illegal move: {move}, from {players[i].position}, by {MCT.whomoves}");
                Console.Error.WriteLine($"Cell occupied by {Grid[move.destination]}");
                Console.Error.WriteLine($"InBounds: {Grid.InBounds(move.destination)}, Free: {Grid.free(move.destination)}");
                if (move.bomb && players[i].param1 == 0)
                    Console.Error.WriteLine("MOVE ILLEGAL CAUSE OF BOMB STUFF");
                return false;
            }
            i++;
        }
        return true;
    }


    public void Move(IEnumerable<Move> moves)
    {
        
        //TODO: this is probably really really really slowing things down
        //remove after the exception is no longer being thrown
        if (!Legal(moves))
            throw new Exception("wat");

        timer++;

        //all the booms are made to the copied grid
        Grid.CopyTo(copiedGrid);

        //tick the bombs
        for (int i = 0; i < bombs.Count; i++)
        {
            Entity b = Grid[bombs[i]];
            if (b.param1 > 0)
                b.param1--;
            if (b.param2 > 0)
                copiedGrid[b.position] = b;
            if (b.param1 == 0)
            {
                if (b.param2 > 0)
                {
                    try
                    {
                        Boom(b);
                    }
                    catch(Exception ex)
                    {
                        Console.Error.WriteLine(ex.StackTrace);
                        Console.Error.WriteLine($"many bombs, tried booming {b}");
                        Console.Error.WriteLine(this);
                        throw ex;
                    }
                }
            }
        }
        //tick the extras
        for (int i = 0; i < extraBombs.Count; i++)
        {
            Entity b = extraBombs[i];
            if (b.param1 > 0)
                b.param1--;
            if (b.param1 == 0)
            {
                if (Grid[b.position].param2 > 0)
                {
                    try
                    {
                        Boom(Grid[b.position]); //both are gonna explode anyway
                                                // but if we trigger only the main bomb
                                                // we have a guarantee of no duplicates, cause it can explode only once
                    }
                    catch (Exception ex)
                    {
                        Console.Error.WriteLine(ex.StackTrace);
                        
                        Console.Error.WriteLine($"many bombs, tried booming {Grid[b.position]}");
                        Console.Error.WriteLine(this);
                        throw ex;
                    }
                }
            }
            extraBombs[i] = b;
        }

        // O(n^2), but n is almost always 0, disgustingly rarely bigger than 1
        for (int i = 0; i < extraBombs.Count; i++)
        {
            // an extra can only explode when it's main bomb explodes, and vice-versa
            if (Grid[extraBombs[i].position].param2 == 0)
            {
                for (int j = 0; j < extraBombs.Count; j++)
                {
                    if (extraBombs[j].extra > i && extraBombs[j].extra < extraBombs.Count)
                    {
                        Entity e = extraBombs[j];
                        e.extra--;
                        extraBombs[j] = e; //each pointer pointing to the right of what we're removing
                        // must get lower by 1
                    }
                    if (j > i && copiedGrid[extraBombs[j].position].extra==j)
                    {
                        Entity e = copiedGrid[extraBombs[j].position];
                        e.extra--;
                        copiedGrid[extraBombs[j].position] = e;
                        // if we're moving and are directly above a non-extra bomb
                        // update the non-extra bomb
                    }
                }
                extraBombs.RemoveAt(i);
                i--;
            }
        }
        bombs.RemoveAll(b =>
        {
            if (Grid[b].param2 == 0 && !copiedGrid.free(b) && copiedGrid[b].type != 2)
            {
                Console.Error.WriteLine($"ok, {copiedGrid[b]} has problems, time {timer}");
                throw new Exception($"ok, {copiedGrid[b]} has problems");
            }
            return Grid[b].param2 == 0;
        });

        //accept the state

        copiedGrid.CopyTo(Grid);

        //consider the moves on the regular grid
        int player = 0;
        foreach (Move move in moves)
        {
            try
            {
                if (move.bomb)
                    DropBomb(player);
            }
            catch(Exception e)
            {
                Console.Error.WriteLine(this);
                Console.Error.WriteLine($"bad move: {move}");
                throw e;
            }
            players[player].position = move.destination;
            if (!Grid[players[player].position].empty && Grid[players[player].position].type == 2)
            {
                switch(Grid[players[player].position].param1)
                {
                    case 1:
                        players[player].param2++;
                        upgrades[player]++;
                        break;
                    case 2:
                        players[player].param1++;
                        upgrades[player]++;
                        break;
                }
            }
            player++;
        }
        foreach (Entity p in players)
            if (Grid[p.position].type == 2)
                Grid[p.position] = new Entity();
    }

    public IEnumerable<IEnumerable<Move>> LegalMoves()
    {
        IEnumerable<Point>[] playerMoves = new IEnumerable<Point>[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            Point pos = players[i].position;
            playerMoves[i] = pos.Neighbours().
                  Where(p => Grid.free(p)).Concat(Enumerable.Repeat(pos,1));
        }
        var res = playerMoves[0].Select(p => Enumerable.Repeat(new Move(false, p),1));
        if (players[0].param1 > 0 && Grid.free(players[0].position))
            res = res.Concat(playerMoves[0].Select(p => Enumerable.Repeat(new Move(true, p), 1)));

        for (int i = 1; i < playersAmm; i++)
        {
            IEnumerable<Move> myMoves = playerMoves[i].Select(p => new Move(false, p) );
            if (players[i].param1 > 0 && Grid.free(players[i].position))
                myMoves = myMoves.Concat(playerMoves[i].Select(p =>  new Move(true, p) ));

            res = res.SelectMany(a => myMoves, (rest, mine) => rest.Concat(Enumerable.Repeat(mine, 1)));
        }

        return res;

    }

    public int BoxesInRange(Point p, int range)
    {
        int res = 0;
        bool right = true, left = true, up = true, down = true;
        for (int r = 1; r < range; r++)
        {
            if (right && Grid.InBounds(p.x + r, p.y) && Grid.blocking(p.x + r, p.y))
            {
                right = false;
                if (Grid[p.x + r, p.y].type == 3)
                    res++;
            }
            if (left && Grid.InBounds(p.x - r, p.y) && Grid.blocking(p.x - r, p.y))
            {
                left = false;
                if (Grid[p.x - r, p.y].type == 3)
                    res++;
            }
            if (up && Grid.InBounds(p.x, p.y - r) && Grid.blocking(p.x, p.y - r))
            {
                up = false;
                if (Grid[p.x, p.y - r].type == 3)
                    res++;
            }
            if (down && Grid.InBounds(p.x, p.y + r) && Grid.blocking(p.x, p.y + r))
            {
                down = false;
                if (Grid[p.x, p.y + r].type == 3)
                    res++;
            }
        }
        return res;
    }

    public void RandomMove()
    {
        Move[] moves = new Move[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            IEnumerable<Point> dests = players[i].position.Neighbours().
                  Where(p => Grid.free(p)).Concat(Enumerable.Repeat(players[i].position, 1));
            if (dests.Count() == 0)
            {
                Console.Error.WriteLine(this);
                foreach(Point p in players[i].position.Neighbours())
                {
                    Console.Error.WriteLine($"pos {p}: {Grid[p]}");
                }
                throw new Exception($"wat, player {i} can't move from {players[i].position}");
            }
                
            int m = MCT.random.Next(dests.Count());
            if (m == 0)
                m = MCT.random.Next(dests.Count());
            moves[i].destination = dests.ElementAt(m);
            
            if (MCT.random.Next() % 2 == 0  
                && players[i].param1 > 0 
                && Grid.free(players[i].position)
                && BoxesInRange(players[i].position, (int)players[i].param2) > 0)
                moves[i].bomb = true;
            else
                moves[i].bomb = false;
        }
        MCT.whomoves = 1;
        Move(moves);
    }
    #endregion

    // board.Clear(), followed by board.Grid.UpdateRow() and board.UpdateEntity()
    // load a complete gamestate to the board
    #region utils
    public void Clear()
    {
       // Move[] moves = new Move[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            //moves[i].destination = players[i].position;
           // moves[i].bomb = false;
            guessedMoves[i].bomb = false;
        }
        Grid.CopyTo(copiedGrid);
        foreach(Point bomb in bombs)
            if (Grid[bomb].param1 == 1 && Grid[bomb].param2 > 0)
            {
                Boom(Grid[bomb]);
            }
        foreach (Entity bomb in extraBombs)
            if (bomb.param1 == 1 && bomb.param2 > 0)
            {
                Boom(bomb);
            }
        copiedGrid.CopyTo(Grid);
        bombs.Clear();
        extraBombs.Clear();
        this.timer++;
    }

    public void UpdateEntity(Entity e)
    {

        if (e.type == 0)
        {
            guessedMoves[e.owner].destination = e.position;
            Console.Error.WriteLine($"Player {e.owner} moves onto {Grid[e.position]}");
            if (!Grid[e.position].empty && Grid[e.position].type == 2)
                upgrades[e.owner]++;

            players[e.owner] = e;
        }
        else
        {
            if (e.type == 1)
            {
                if (e.param1 == 8)
                {
                    guessedMoves[e.owner].bomb = true;
                }
                bombs.Add(e.position);
            }
            else
            { 
                if (e.type == 2)
                {
                    e.owner = 0;
                    e.param2 = 0;
                }
            }
            copiedGrid[e.position] = e;
        }

    }

    public static bool operator ==(Board b1, Board b2)
    {
        if (b1.bombs.Count != b2.bombs.Count)
        {
            Console.Error.WriteLine($"bc {b1.bombs.Count} != {b2.bombs.Count}");
            return false;
        }
        for (int i = 0; i < b1.bombs.Count; i++)
        {
            if (b1.bombs[i] != b2.bombs[i])
            {
                Console.Error.WriteLine($"b {b1.bombs[i]} != {b2.bombs[i]}");
                return false;
            }
        }
        for (int i = 0; i < b1.playersAmm; i++)
        {
            if (b1.players[i] != b2.players[i])
            {
                Console.Error.WriteLine($"p {b1.players[i]} != {b2.players[i]}");
                return false;
            }
            if (b1.upgrades[i] != b2.upgrades[i])
            {
                Console.Error.WriteLine($"u {b1.upgrades[i]} != {b2.upgrades[i]}");
                return false;
            }
            if (b1.scores[i] != b2.scores[i])
            {
                Console.Error.WriteLine($"s {b1.scores[i]} != {b2.scores[i]}");
                return false;
            }
        }
        if (b1.extraBombs.Count != b2.extraBombs.Count)
        {
            Console.Error.WriteLine($"exc {b1.extraBombs.Count} != {b2.extraBombs.Count}");
            return false;
        }
        for (int i = 0; i < b1.extraBombs.Count; i++)
        {
            if (b1.extraBombs[i] != b2.extraBombs[i])
                if (b1.bombs[i] != b2.bombs[i])
                {
                    Console.Error.WriteLine($"ex {b1.extraBombs[i]} != {b2.extraBombs[i]}");
                    return false;
                }
        }
        for (int y = 0; y < b1.Grid.height; y++)
            for (int x = 0; x < b1.Grid.width; x++)
                if (b1.Grid[x, y] != b2.Grid[x, y])
                {
                    Console.Error.WriteLine($"g at {x},{y} {b1.Grid[x,y]} != {b2.Grid[x,y]}");
                    return false;
                }

        return true;
        
    }

    public static bool operator !=(Board b1, Board b2)
    {
        return !(b1 == b2);
    }

    public override String ToString()
    {
        Grid g = new Grid(Grid.width, Grid.height);
        Grid.CopyTo(g);
        StringBuilder res = new StringBuilder();
        res.AppendLine($"TIME: {timer}");
       
        foreach (Point bomb in bombs)
        {
            res.Append(Grid[bomb]);
            res.AppendLine();
        }
        foreach (Entity bomb in extraBombs)
        {
            res.Append("EXTRA: ");
            res.Append(bomb);
            res.AppendLine();
        }
        foreach (Entity player in players)
        {
            res.Append(player.ToString());
            res.Append($" SCORE: {scores[player.owner]}");
            res.Append($" U: {upgrades[player.owner]}");

            res.AppendLine();
        }
        res.Append("\n\n");
        res.Append(g.ToString());
        return res.ToString();
    }
    #endregion
}

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/




class Player
{

    static void Main(string[] args)
    {
        Entity e1 = new Entity(1, 1, 1, 1, new Point(1, 1));
        Entity e2 = new Entity(1, 1, 1, 1, new Point(1, 1));
        DateTime deadline = DateTime.Now.AddMilliseconds(980);
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        uint width = uint.Parse(inputs[0]);
        uint height = uint.Parse(inputs[1]);
        int myId = int.Parse(inputs[2]);

        Board board = new Board(width, height, 2);

        //first turn
        for (int i = 0; i < height; i++)
        {
            string row = Console.ReadLine();
            foreach (char c in row)
                if (c != '.')
                    board.remainingBoxes++;
            board.Grid.UpdateRow(i, row);
        }

        int entities = int.Parse(Console.ReadLine());
        for (int i = 0; i < entities; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            Entity e = new Entity();
            e.empty = false;
            e.extra = 2047;
            e.isExtra = false; e.type = uint.Parse(inputs[0]);
            e.owner = uint.Parse(inputs[1]);
            e.xPos = uint.Parse(inputs[2]);
            e.yPos = uint.Parse(inputs[3]);
            e.param1 = uint.Parse(inputs[4]);
            e.param2 = uint.Parse(inputs[5]);
            board.UpdateEntity(e);
        }

        //TestSim(200, board);
        for (int i = 0; i < board.playersAmm; i++)
            board.upgrades[i] = 0;
        Console.Error.WriteLine(board);

        MCT mct = new MCT(board, myId);


        Console.WriteLine(mct.Run(deadline));

        // game loop
        while (true)
        {
            deadline = DateTime.Now.AddMilliseconds(85);
            board.Clear();
            for (int i = 0; i < height; i++)
            {
                string row = Console.ReadLine();
                board.copiedGrid.UpdateRow(i, row);
            }
            entities = int.Parse(Console.ReadLine());
            for (int i = 0; i < entities; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                Entity e = new Entity();
                e.empty = false;
                e.extra = 2047;
                e.isExtra = false;
                e.type = uint.Parse(inputs[0]);
                e.owner = uint.Parse(inputs[1]);
                e.xPos = uint.Parse(inputs[2]);
                e.yPos = uint.Parse(inputs[3]);
                e.param1 = uint.Parse(inputs[4]);
                e.param2 = uint.Parse(inputs[5]);
                board.UpdateEntity(e);
            }
            board.copiedGrid.CopyTo(board.Grid);
            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            mct.Reuse(board.guessedMoves);
            Console.WriteLine(mct.Run(deadline));

            Console.Error.WriteLine($"{(deadline-DateTime.Now).Milliseconds}ms left");

        }
    }

}



class MCT
{
    public static int whomoves = -1;
    MCTNode root;
    public static readonly Random random = new Random();
    public static readonly float explorationRate = 1;
    Board board; //represents the state of root node
    int MyPlayerId;


    public MCT(Board board, int myid)
    {
        this.board = board;
        MyPlayerId = myid;
        root = new MCTNode(board, null);
    }

    public void Reuse(Move[] moves)
    {
        int c = 0;
        for (int i = 0; i < root.Children.Length; i++)
        {
            MCTNode child = root.Children[i];
            int m = 0;
            bool thisIsIt = true;
            foreach (Move move in root.Moves[i])
            {
                if (move != moves[m])
                {
                    thisIsIt = false;
                    break;
                }
                m++;
            }
            if (thisIsIt)
            {
                root = child;
                if (root == null)
                {
                    Console.Error.WriteLine("Had to make a new tree");
                    root = new MCTNode(board, null);
                }
                else
                {
                    if (root.Board != board)
                    {
                        Console.Error.WriteLine("Difference!");
                        Console.Error.WriteLine($"left (root) {root.Board}");
                        Console.Error.WriteLine($"root.parent {root.Parent.Board}");
                        Console.Error.WriteLine($"right (main) {board}");

                        throw new Exception("cannot into sim");
                    }
                    root.Parent = null;

                }
                return;
            }
            c++;
        }
        Console.Error.WriteLine("Nothing to reuse, wth?");
        Console.Error.WriteLine($"Real {board}");
        Console.Error.WriteLine($"root: {root.Board}");
        Console.Error.WriteLine("Apparently the move we guessed is not legal on it");
        foreach (Move m in moves)
            Console.Error.Write($"{m}, ");
        throw new Exception("nothing to reuse");
    }

    public void Rebind()
    {
        root = new MCTNode(board, null);
    }

    public Move Run(DateTime deadline)
    {
        Console.Error.WriteLine($"starting search, roottime {root.Board.timer}");
        if (DateTime.Now >= deadline)
        {
            Console.Error.WriteLine("srsly? Time gone before I started");
        }

        while (DateTime.Now < deadline)
        {
            Board curBoard = board.Copy();
            MCTNode vl = TreePolicy(root, curBoard);
            // after TreePolicy curBoard represents the state
            // of the returned node
            int[] scores = DefaultPolicy(curBoard);
            BackUp(vl, scores);
        }
        if (root.expansion == 0)
            return root.Moves[0].ElementAt(MyPlayerId);
        Console.Error.WriteLine($"Let's see who's the winner, root pulled {root.TimesPulled} times, has {root.expansion} children!");

        int winner = root.BestChild(MyPlayerId);
        Console.Error.WriteLine($"The winner node had {root.Children[winner].TimesPulled} pulls, rating: {root.RateChild(winner,MyPlayerId)}");
        foreach (Move m in root.Moves[winner])
            Console.Error.Write($"{m}, ");
        Console.Error.WriteLine($"this move makes {root.MoveSenses[winner]} sense");
        return root.Moves[winner].ElementAt(MyPlayerId);
    }

    void BackUp(MCTNode v, int[] scores)
    {
        while (v != null)
        {
            v.TimesPulled++;
            for (int i = 0; i < scores.Length; i++)
            {
                v.scores[i] += scores[i];
            }
            v = v.Parent;
        }
    }

    MCTNode TreePolicy(MCTNode v, Board curBoard)
    {
        List<Move> movvs = new List<Move>();

        MCTNode cur = v;
        int time = curBoard.timer;
        while (!curBoard.Terminal) //"v is not terminal"
        {
            if (!cur.FullyExpanded)
            {
                try
                {
                    MCTNode res =  cur.Expand(curBoard);
                    return res;
                }
                catch (Exception e)
                {
                    Console.Error.WriteLine("-----I think----");
                    Console.Error.WriteLine(curBoard);
                    Console.Error.WriteLine("-----Node thinks----");
                    Console.Error.WriteLine(cur.Board);
                    throw e;
                }
            }
            else
            {
                int winner = cur.BestChild(MyPlayerId);
                whomoves = 2;
                try
                {
                    curBoard.Move(cur.Moves[winner]);
                }
                catch(Exception e)
                {
                    Console.Error.WriteLine("Moves:");
                    foreach (Move move in movvs)
                        Console.Error.WriteLine("movvs");
                    Console.Error.WriteLine("-----I think----");
                    Console.Error.WriteLine(curBoard);
                    Console.Error.WriteLine("-----Node thinks----");
                    Console.Error.WriteLine(cur.Board);
                    throw e;
                }
                foreach (Move move in cur.Moves[winner])
                    movvs.Add(move);
                cur = cur.Children[winner];
            }
        }
        return cur;
    }


    int[] DefaultPolicy(Board curBoard)
    {
        int remBoxes = curBoard.remainingBoxes;
        int time = curBoard.timer;
        while (curBoard.remainingBoxes > remBoxes * 0.9 && !curBoard.Terminal && curBoard.timer - time < 32)
        {
            curBoard.RandomMove();
        }
        //Console.WriteLine($"----after sim for {curBoard.timer - time}----");
        //Console.WriteLine($"remBoxes * 0.9 = {remBoxes * 0.9}, remaining: {curBoard.remainingBoxes}");
        for(int i = 0; i < board.playersAmm; i++)
        {
            //Console.Error.WriteLine($"player {i} has score {curBoard.scores[i]}, upgrades {board.upgrades[i]}");
            curBoard.scores[i] += board.upgrades[i]*20;
        }
        return curBoard.scores;
    }
    
}

class MCTNode
{
    public IEnumerable<Move>[] Moves;
    public int ChildrenCount;
    public MCTNode[] Children;
    public MCTNode Parent;
    public bool FullyExpanded { get { return expansion == ChildrenCount; } }
    public int TimesPulled;
    public int[] MoveSenses;

    //mean score of a single player in this Node's state
    public float MeanScoreOfPlayer(int which)
    {
        return ((float)scores[which]) / TimesPulled;
    }

    public int[] scores;
    public int expansion;

    public MCTNode Expand(Board board)
    {
        MCT.whomoves = 3;
        board.Move(Moves[expansion]); //state(newChild) = f(state(this), move);
        

        Children[expansion] = new MCTNode(board, this); 
        expansion++;
        return Children[expansion - 1];
    }

    public float RateChild(int i, int playerID)
    {
        float myScore = Children[i].MeanScoreOfPlayer(playerID);
        float theirScore = 0;
        float maxEnemy = 0;
        for (int j = 0; j < scores.Length; j++)
        {
            if (j != playerID)
            {
                theirScore += Children[i].MeanScoreOfPlayer(j);
                if (Children[i].MeanScoreOfPlayer(j) > maxEnemy)
                    maxEnemy = Children[i].MeanScoreOfPlayer(j);
            }
        }
        theirScore /= scores.Length - 1;
        return (myScore - maxEnemy) * theirScore / (Math.Abs(myScore - theirScore) + 10);
    }

    public int BestChild(int playerID)
    {
        int theOne = -1;
        float bestScore = int.MinValue;
        for (int i = 0; i < ChildrenCount; i++)
        {
            if (Children[i] != null)
            {

                float score = 2000 + RateChild(i, playerID);
                if (score < 0)
                    throw new Exception("less!!!!");
                score += MCT.explorationRate * (float)Math.Sqrt(2 * Math.Log(TimesPulled) / Children[i].TimesPulled);
                    score *= MoveSenses[i];
                if (score > bestScore)
                {
                    bestScore = score;
                    theOne = i;
                }
            }
        }
        return theOne;
    }

    public Board Board;
    public MCTNode(Board board, MCTNode par)
    {
        Board = board.Copy();
        Moves = board.LegalMoves().OrderBy(x => MCT.random.Next()).ToArray();
        MoveSenses = new int[Moves.Count()];
        for (int i = 0; i < Moves.Count(); i++)
        {
            MoveSenses[i] = 4096;
            int player = 0;
            foreach(Move m in Moves[i])
            {
                if (m.bomb)
                    MoveSenses[i] = Math.Min(MoveSenses[i], board.BoxesInRange(board.players[player].position, (int)board.players[player].param2));
                player++;
            }
            if (MoveSenses[i] == 4096)
                MoveSenses[i] = 1;
        }
        ChildrenCount = Moves.Length;

        Children = new MCTNode[ChildrenCount];
        Parent = par;
        TimesPulled = 0;
        expansion = 0;
        scores = new int[board.playersAmm];
    }
}

struct Entity : IEquatable<Entity>
{
    private uint _val;

    public Point position
    {
        get
        {
            return new Point(xPos, yPos);
        }
        set
        {
            yPos = (uint)value.y;
            xPos = (uint)value.x;
        }

    }

    // get: << (31-left) >> (31 - left + right)
    // set: << right

    public bool Equals(Entity e)
    {
        return e.empty && this.empty ||_val == e._val;
    }

    public static bool operator ==(Entity e1, Entity e2)
    {
        return (e1.Equals(e2));
    }

    public static bool operator !=(Entity e1, Entity e2)
    {
        return (!e1.Equals(e2));
    }

    public bool isExtra //0-1, bit 31
    {   //1 means it's an extra
        get
        {
            return 1 == (_val >> 31);
        }
        set
        {
            if (value)
                _val |= (uint)1 << 31;
            else
                _val &= ~((uint)1 << 31);

        }
    }

    public uint extra // 0-2047 bits 30 to 20
    {
        get
        {
            return (_val << 1) >> 21;
        }
        set
        {
            if (value > 2047)
                throw new Exception("extra is 0-2047");
            _val &= ~((uint)2047 << 20);
            _val |= value << 20;
        }
    }

    public bool empty //0-1, bit 19
    {
        //0 is empty
        get
        {
            return 0 == ((_val << 12) >> 31);
        }
        set
        {
            if (value)
                _val &= ~(uint)(1 << 19);
            else
                _val |= (1 << 19);
        }
    }
   
    public uint yPos // 0-15, bits 18 to 15
    {
        get
        {
            return (_val << 13) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("ypos is 0-15");
            _val &= ~(uint)(15 << 15);
            _val |= value << 15;
        }
    }
    public uint xPos // 0-15, bits 14 to 11
    {
        get
        {
            return (_val << 17) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("xpos is 0-15");
            _val &= ~(uint)(15 << 11);
            _val |= value << 11;
        }
    }

    /// <summary>
    /// 0 is player, 1 is bomb, 2 is item, 3 is box
    /// </summary>
    ///
    public uint type // 0-3, bits 10 to 9
    {
        get
        {
            return (_val << 21) >> 30;
        }
        set
        {
            if (value > 3)
                throw new Exception("type is 0-3");
            _val &= ~(uint)(3 << 9);
            _val |= value << 9;
        }
    }

    /// <summary>
    /// id of the player/player who put the bomb
    /// </summary>
    public uint owner // 0-1, 8th bit
    {
        get
        {
            return (_val << 23) >> 31;
        }
        set
        {
            if (value > 1)
                throw new Exception("owner is 0-1");
            _val &= ~(uint)(1 << 8);
            _val |= value << 8;
        }
    }

    /// <summary>
    /// bombs remaining / bomb timer / item type
    /// </summary>
    public uint param1 // 0-15, bits 7 to 4
    {
        get
        {
            return (_val << 24) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("param1 is 0-15");
            _val &= ~(uint)(15 << 4);
            _val |= value << 4;
        }
    }

    /// <summary>
    /// explosion range
    /// </summary>
    public uint param2 //0-15, bits 3 to 0
    {
        get
        {
            return (_val << 28) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("param2 is 0-15");
            _val &= ~(uint)15;
            _val |= value;
        }
    }

    public Entity(uint t, uint own, uint p1, uint p2, Point position)
    {
        _val = 0;
        this.position = position;
        type = t; owner = own; param1 = p1; param2 = p2;
        empty = false;
    }


    public override string ToString()
    {

        String t = "";
        if (empty)
            t = "(empty)";
        if (isExtra)
            t += "(extra)";
        if (extra != 2047)
            t += $"(ptr {extra})";
        switch(type)
        {
            case 0:
                t+= "player";
                break;
            case 1:
                t+= "bomb";
                break;
            case 2:
                t+= "item";
                break;
            case 3:
                t += "box";
                break;
        }
        return $"{t} of team {owner} at {position}, p1 {param1}, p2 {param2}";
    }
}

struct Point
{
    public int x;
    public int y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    public Point(uint x, uint y)
    {
        this.x = (int)x;
        this.y = (int)y;
    }

    public IEnumerable<Point> Neighbours()
    {
        yield return new Point(x - 1, y);
        yield return new Point(x + 1, y);
        yield return new Point(x, y - 1);
        yield return new Point(x, y + 1);
    }

    public override string ToString()
    {
        return $"({x},{y})";
    }

    public static bool operator !=(Point p1, Point p2)
    {
        return (p1.x != p2.x || p1.y != p2.y);
    }

    public static bool operator ==(Point p1, Point p2)
    {
        return (p1.x == p2.x && p1.y == p2.y);
    }

}

struct Move
{
    public bool bomb;
    public Point destination;

    public Move(bool b, Point p)
    {
        bomb = b;
        destination = p;
    }

    public static bool operator !=(Move m1, Move m2)
    {
        return (m1.bomb != m2.bomb || m1.destination != m2.destination);
    }

    public static bool operator ==(Move m1, Move m2)
    {
        return (m1.bomb == m2.bomb && m1.destination == m2.destination);
    }

    public override string ToString()
    {
        String comm = bomb ? "BOMB" : "MOVE";
        return $"{comm} {destination.x} {destination.y}";
    }
}

class Grid
{
    Entity[,] ents;
    public uint height { get; private set; }
    public uint width { get; private set; }

    /// <summary>
    /// true if a player can move on this cell, false otherwise
    /// </summary>
    public bool free(int x, int y)
    {
        // false if cell out of bounds, is a box, or is a bomb
        return (InBounds(x, y) && (ents[y,x].empty || (ents[y, x].type != 3 && ents[y, x].type != 1)));
    }
    public bool free(Point p)
    {
        // false if cell out of bounds, is a box, or is a bomb
        return (InBounds(p) && (ents[p.y, p.x].empty || (ents[p.y, p.x].type != 3 && ents[p.y, p.x].type != 1)));
    }

    /// <summary>
    /// true if this cell stops a bomb's explosion
    /// </summary>
    public bool blocking(int x, int y)
    {
        // true if cell out of bounds, is a box, an item, or a bomb
        return (ents[y, x].type != 0 && !ents[y,x].empty);
    }
    public bool blocking(Point p)
    {
        // true if cell out of bounds, is a box, or is a bomb
        return (ents[p.y, p.x].type != 0);
    }

    public Entity this[Point p]
    {
        get
        {
            return ents[p.y, p.x];
        }
        set
        {
            ents[p.y, p.x] = value;
        }
    }

    public Entity this[int x, int y]
    {
        get
        {
            if (!InBounds(x, y))
                throw new Exception("blah");
            return ents[y, x];
        }
        set
        {
            ents[y, x] = value;
        }
    }

    public override String ToString()
    {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < height; i++)
        {
            for (int j = 0; j < width; j++)
            {
                if (this[j, i].empty)
                    builder.Append(".");
                else if (this[j, i].type == 3)
                {
                    builder.Append(this[j, i].param1);
                }
                else if (this[j, i].type == 1)
                {
                    if (this[j, i].param2 == 0)
                        builder.Append("?");
                    else
                        builder.Append("b");
                }
                else if (this[j, i].type == 2)
                {
                    if (this[j, i].param1 == 1)
                        builder.Append("*");
                    else if (this[j, i].param1 == 2)
                        builder.Append("+");
                    else
                        builder.Append("?");
                }
                else if (this[j, i].type == 0)
                    builder.Append("?");
               
            }
            builder.AppendLine();
        }
        return builder.ToString();
    }

    public bool InBounds(Point p)
    {
        return (p.x >= 0 && p.x < width && p.y >= 0 && p.y < height);
    }
    public bool InBounds(int x, int y)
    {
        return (x >= 0 && x < width && y >= 0 && y < height);
    }
    public bool InBounds(uint x, uint y)
    {
        return (x < width && y < height);
    }
    public Grid(uint width, uint height)
    {
        this.width = width;
        this.height = height;
        ents = new Entity[height,width];
    }
    public void CopyTo(Grid grid)
    {
        
        Array.Copy(ents, grid.ents, width * height);
    }

    public void UpdateRow(int which, String row)
    {
        for (int i = 0; i < row.Length; i++)
        {
            Entity t = new Entity();
            if (row[i] == '.')
                t.empty = true;
            else
            {
                t.empty = false;
                t.type = 3;
                t.param1 = (uint)(row[i] - 48);
                t.xPos = (uint)i;
                t.yPos = (uint)which;
                t.owner = 0;
                t.extra = 2047;
                t.isExtra = false;
                t.param2 = 0;
            }
            ents[which, i] = t;
        }

    }
}
