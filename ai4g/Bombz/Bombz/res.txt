using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Collections;



class Board
{
    public static readonly uint bombTimer = 8;

    public Grid Grid;
    public int playersAmm;
    public int timer;

    public Move[] guessedMoves;
    public List<Point> bombs;
    public Entity[] players;
    public int[] scores;
    public int remainingBoxes;
    public bool Terminal
    {
        get { return remainingBoxes == 0; }
    }

    private Grid copiedGrid;

    public Board(uint width, uint height, int playersAmm)
    {
        Grid = new Grid(width, height);
        copiedGrid = new Grid(width, height);
        this.playersAmm = playersAmm;

        bombs = new List<Point>();

        players = new Entity[playersAmm];

        scores = new int[playersAmm];

        for (int i = 0; i < playersAmm; i++)
            scores[i] = 0;

        guessedMoves = new Move[playersAmm];
        remainingBoxes = 0;
        timer = 0;
    }

    public Board Copy()
    {
        Board res = new Board(Grid.width, Grid.height, playersAmm);
        Grid.CopyTo(res.Grid);
        res.bombs = bombs.ConvertAll(b => b);
        players.CopyTo(res.players, 0);
        scores.CopyTo(res.scores, 0);
        res.remainingBoxes = remainingBoxes;
        res.timer = timer;
        return res;
    }


    #region sim
    public void Boom(Entity e)
    {
        if (e.param2 == 0) //it's a bomb's ghost
        {
            Console.Error.WriteLine("GHOST TRIGGERED");
            return;
        }
        int j;
        Entity bomb = e;
        int x = (int)e.xPos;
        int y = (int)e.yPos;
        bomb.param2 = 0;
        Grid[bomb.position] = bomb; //bomb stays on the grid, but we reduce it's range to 0
        copiedGrid[x, y] = new Entity(); // it is not on the new grid, though

        players[e.owner].param1++;

        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x + j, y) && Grid.blocking(x+j, y))
            {
                Entity en = Grid[x + j, y];
                Entity res = en;
                res.empty = true;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.type = 2;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x + j, y] = res;
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x - j, y) && Grid.blocking(x - j, y))
            {
                Entity en = Grid[x - j, y];
                Entity res = en;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.type = 2;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x - j, y] = new Entity();
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y + j) && Grid.blocking(x, y + j))
            {
                Entity en = Grid[x, y + j];
                Entity res = en;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.type = 2;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x, y + j] = res;
                break;
            }
        }
        for (j = 1; j < e.param2; j++)
        {
            if (Grid.InBounds(x, y - j) && Grid.blocking(x, y - j))
            {
                Entity en = Grid[x, y - j];
                Entity res = en;
                if (en.type == 3) //box? score
                {
                    scores[e.owner]++;
                    remainingBoxes--;
                    if (en.param1 > 0)
                    {
                        res.empty = false;
                        res.type = 2;
                    }
                }
                else if (en.type == 1 && en.param2 > 0) //bomb? boom
                    Boom(en);
                // item? simply destroy
                copiedGrid[x, y - j] = res;
                break;
            }
        }
    }

    public void DropBomb(int playerID)
    {
        if (!Grid.free(players[playerID].position))
            return;
            //throw new Exception($"droppin bomb by ({players[playerID]}) on top of ({Grid[players[playerID].position]})");
        bombs.Add(players[playerID].position);
        Grid[players[playerID].position] = new Entity(1, players[playerID].owner, bombTimer, players[playerID].param2, players[playerID].position);
        if (players[playerID].param1 > 0) players[playerID].param1--;
    }

    public bool Legal(IEnumerable<Move> moves)
    {
        int i = 0;
        foreach (var move in moves)
        {
            if ((!Grid.free(move.destination) && move.destination != players[i].position) || move.bomb && players[i].param1 == 0)
            {
                Console.Error.WriteLine($"Illegal move: {move}, from {players[i].position}, by {MCT.whomoves}");
                Console.Error.WriteLine($"Cell occupied by {Grid[move.destination]}");
                Console.Error.WriteLine($"InBounds: {Grid.InBounds(move.destination)}, Free: {Grid.free(move.destination)}");
                if (move.bomb && players[i].param1 == 0)
                    Console.Error.WriteLine("MOVE ILLEGAL CAUSE OF BOMB STUFF");
                return false;
            }
            i++;
        }
        return true;
    }

    public void Move(IEnumerable<Move> moves)
    {

        //TODO: this is probably really really really slowing things down
        //remove after the exception is no longer being thrown
        if (!Legal(moves))
            throw new Exception("wat");

        timer++;

        //all the booms are made to the copied grid
        Grid.CopyTo(copiedGrid);

        //tick the bombs
        for (int i = 0; i < bombs.Count; i++)
        {
            Entity b = Grid[bombs[i]];
            if (b.param1 > 0)
                b.param1--;
            copiedGrid[b.position] = b;
            if (b.param1 == 0)
            {
                if (b.param2 > 0)
                    Boom(b);
            }
        }
        bombs.RemoveAll(b => Grid[b].param2 == 0);

        //accept the state

        copiedGrid.CopyTo(Grid);

        //consider the moves on the regular grid
        int player = 0;
        foreach (Move move in moves)
        {
            if (move.bomb)
                DropBomb(player);
            players[player].position = move.destination;
            if (Grid[players[player].position].type == 2)
            {
                switch(Grid[players[player].position].param1)
                {
                    case 1:
                        players[player].param2++;                            
                        break;
                    case 2:
                        players[player].param1++;
                        break;
                }
            }
            player++;
        }
    }

    public IEnumerable<IEnumerable<Move>> LegalMoves()
    {
        IEnumerable<Point>[] playerMoves = new IEnumerable<Point>[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            Point pos = players[i].position;
            playerMoves[i] = pos.Neighbours().
                  Where(p => Grid.free(p)).Concat(Enumerable.Repeat(pos,1));
        }
        var res = playerMoves[0].Select(p => Enumerable.Repeat(new Move(false, p),1));
        if (players[0].param1 > 0)
            res = res.Concat(playerMoves[0].Select(p => Enumerable.Repeat(new Move(true, p), 1)));

        for (int i = 1; i < playersAmm; i++)
        {
            IEnumerable<Move> myMoves = playerMoves[i].Select(p => new Move(false, p) );
            if (players[i].param1 > 0)
                myMoves = myMoves.Concat(playerMoves[i].Select(p =>  new Move(true, p) ));

            res = res.SelectMany(a => myMoves, (rest, mine) => rest.Concat(Enumerable.Repeat(mine, 1)));
        }

        return res;

    }

    public void RandomMove()
    {
        Move[] moves = new Move[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            IEnumerable<Point> dests = players[i].position.Neighbours().
                  Where(p => Grid.free(p)).Concat(Enumerable.Repeat(players[i].position, 1));
            if (dests.Count() == 0)
            {
                Console.Error.WriteLine(this);
                foreach(Point p in players[i].position.Neighbours())
                {
                    Console.Error.WriteLine($"pos {p}: {Grid[p]}");
                }
                throw new Exception($"wat, player {i} can't move from {players[i].position}");
            }
                
            int m = MCT.random.Next(dests.Count());
            if (m >= dests.Count())
                throw new Exception($"WAT, m {m}, dests.count {dests.Count()}");
            if (i >= moves.Count())
                throw new Exception("WAT");
            moves[i].destination = dests.ElementAt(m);
            if (players[i].param1 > 0 && MCT.random.Next() % 2 == 0)
                moves[i].bomb = true;
            else
                moves[i].bomb = false;
        }
        MCT.whomoves = 1;
        Move(moves);
    }
    #endregion

    // board.Clear(), followed by board.Grid.UpdateRow() and board.UpdateEntity()
    // load a complete gamestate to the board
    #region utils
    public void Clear()
    {
        Move[] moves = new Move[playersAmm];
        for (int i = 0; i < playersAmm; i++)
        {
            moves[i].destination = players[i].position;
            moves[i].bomb = false;
            guessedMoves[i].bomb = false;
        }
        Move(moves);
        bombs.Clear();
    }

    

    public void UpdateEntity(Entity e)
    {
        if (e.type == 0)
        {
            guessedMoves[e.owner].destination = e.position;
            players[e.owner] = e;
        }
        else
        {

            if (e.type == 1)
            {
                if (e.param1 == 8)
                {
                    Console.Error.WriteLine($"new bomb of team {e.owner}");
                    guessedMoves[e.owner].bomb = true;
                }
                bombs.Add(e.position);
            }
            Grid[e.position] = e;
        }

    }

    public override String ToString()
    {
        Grid g = new Grid(Grid.width, Grid.height);
        Grid.CopyTo(g);
        StringBuilder res = new StringBuilder();
        res.AppendLine($"TIME: {timer}");
        foreach (Point bomb in bombs)
        {
            res.Append(Grid[bomb].ToString());
            res.AppendLine();
        }
        foreach (Entity player in players)
        {
            res.Append(player.ToString());
            res.Append($" SCORE: {scores[player.owner]}");
            res.AppendLine();
        }
        res.Append("\n\n");
        res.Append(g.ToString());
        return res.ToString();
    }
    #endregion
}

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/




class Player
{

    static void TestSim(int turns, Board board)
    {
        String[] ms =
{ };

        Console.WriteLine();
        for (int i = 0; i < turns; i++)
        {
            Console.WriteLine($"turn {i}\n{board}");
           Move[] moves = new Move[board.playersAmm];
           for (int j = 0; j < board.playersAmm; j++)
           {
               string[] inputss = ms[i*board.playersAmm + j].Split(' ');
               char b = char.Parse(inputss[0]);
               int x = int.Parse(inputss[1]);
               int y = int.Parse(inputss[2]);
               moves[j].bomb = b == 'B';
               moves[j].destination.x = x;
               moves[j].destination.y = y;
               Console.WriteLine($"PLAYER {j}: {moves[j]}");
           }

            
            Console.WriteLine();
            board.Move(moves);
        }
    }

    static void Main(string[] args)
    {
        Entity e1 = new Entity(1, 1, 1, 1, new Point(1, 1));
        Entity e2 = new Entity(1, 1, 1, 1, new Point(1, 1));
        DateTime deadline = DateTime.Now.AddMilliseconds(980);
        string[] inputs;
        inputs = Console.ReadLine().Split(' ');
        uint width = uint.Parse(inputs[0]);
        uint height = uint.Parse(inputs[1]);
        int myId = int.Parse(inputs[2]);

        Board board = new Board(width, height, 2);

        //first turn
        for (int i = 0; i < height; i++)
        {
            string row = Console.ReadLine();
            foreach (char c in row)
                if (c == '0')
                    board.remainingBoxes++;
            board.Grid.UpdateRow(i, row);
        }

        int entities = int.Parse(Console.ReadLine());
        for (int i = 0; i < entities; i++)
        {
            inputs = Console.ReadLine().Split(' ');
            Entity e = new Entity();
            e.empty = false;
            e.type = uint.Parse(inputs[0]);
            e.owner = uint.Parse(inputs[1]);
            e.xPos = uint.Parse(inputs[2]);
            e.yPos = uint.Parse(inputs[3]);
            e.param1 = uint.Parse(inputs[4]);
            e.param2 = uint.Parse(inputs[5]);
            board.UpdateEntity(e);
        }

        //TestSim(200, board);

        Console.Error.WriteLine(board);

        MCT mct = new MCT(board, myId);


        Console.WriteLine(mct.Run(deadline));

        // game loop
        while (true)
        {
            deadline = DateTime.Now.AddMilliseconds(90);
            board.Clear();
            for (int i = 0; i < height; i++)
            {
                string row = Console.ReadLine();
                board.Grid.UpdateRow(i, row);
            }
            entities = int.Parse(Console.ReadLine());
            for (int i = 0; i < entities; i++)
            {
                inputs = Console.ReadLine().Split(' ');
                Entity e = new Entity();
                e.empty = false;

                e.type = uint.Parse(inputs[0]);
                e.owner = uint.Parse(inputs[1]);
                e.xPos = uint.Parse(inputs[2]);
                e.yPos = uint.Parse(inputs[3]);
                e.param1 = uint.Parse(inputs[4]);
                e.param2 = uint.Parse(inputs[5]);
                board.UpdateEntity(e);
            }
            Console.Error.WriteLine(board);

            // Write an action using Console.WriteLine()
            // To debug: Console.Error.WriteLine("Debug messages...");
            mct.Reuse(board.guessedMoves);
            Console.Error.WriteLine("Running.....");
            Console.WriteLine(mct.Run(deadline));
        }
    }

}



class MCT
{
    public static int whomoves = -1;
    MCTNode root;
    public static readonly Random random = new Random();
    public static readonly float explorationRate = 1;
    Board board; //represents the state of root node
    int MyPlayerId;
    List<Move> mmss;


    public MCT(Board board, int myid)
    {
        this.board = board;
        MyPlayerId = myid;
        root = new MCTNode(board, null);
        mmss = new List<Move>();
    }

    public void Reuse(Move[] moves)
    {
        if (!root.board.Legal(moves))
        {
            Console.Error.WriteLine("Wat");
            Console.Error.WriteLine(root.board);
        }
        foreach (Move m in moves)
            mmss.Add(m);
        int c = 0;
        for (int i = 0; i < root.Children.Length; i++)
        {
            MCTNode child = root.Children[i];
            int m = 0;
            bool thisIsIt = true;
            foreach (Move move in root.Moves[i])
            {
                if (move != moves[m])
                {
                    thisIsIt = false;
                    break;
                }
                m++;
            }
            if (thisIsIt)
            {
                foreach (Move move in root.Moves[i])
                    Console.Error.WriteLine($"reusing {move}");
                Console.Error.WriteLine($"Time of root is not {child.board.timer}");
                root = child;
                if (root == null)
                {
                    Console.Error.WriteLine("Had to make a new tree");
                    root = new MCTNode(board, null);
                }
                else
                    root.Parent = null;
                return;
            }
            c++;
        }
        Console.Error.WriteLine("Nothing to reuse, wth?");
    }

    public void Rebind()
    {
        root = new MCTNode(board, null);
    }

    public Move Run(DateTime deadline)
    {
        if (DateTime.Now >= deadline)
        {
            Console.Error.WriteLine("srsly? Time gone before I started");
        }

        while (DateTime.Now < deadline)
        {
            Board curBoard = board.Copy();
            MCTNode vl = TreePolicy(root, curBoard);
            // after TreePolicy curBoard represents the state
            // of the returned node
            int[] scores = DefaultPolicy(curBoard);
            BackUp(vl, scores);
        }
        if (root.expansion == 0)
            return root.Moves[0].ElementAt(MyPlayerId);
        Console.Error.WriteLine($"Let's see who's the winner, root pulled {root.TimesPulled} times, has {root.expansion} children!");
        int winner = root.BestChild(MyPlayerId);
        Console.Error.WriteLine($"The winner node had {root.Children[winner].TimesPulled} pulls, scores: ");
        foreach(int score in root.Children[winner].scores)
            Console.Error.Write($"{((float)score) / root.Children[winner].TimesPulled}, ");
        Console.Error.WriteLine();

        return root.Moves[winner].ElementAt(MyPlayerId);
    }

    void BackUp(MCTNode v, int[] scores)
    {
        while (v != null)
        {
            v.TimesPulled++;
            for (int i = 0; i < scores.Length; i++)
            {
                v.scores[i] += scores[i];
            }
            v = v.Parent;
        }
    }

    MCTNode TreePolicy(MCTNode v, Board curBoard)
    {
        if (v == null)
            Console.Error.WriteLine("I have lost my abillity to even");
        MCTNode cur = v;
        int d = 0;
        int time = curBoard.timer;
        while (!curBoard.Terminal) //"v is not terminal"
        {
            if (time+d != cur.board.timer)
                throw new Exception("life is strange");
            if (cur == null)
            {
                Console.Error.WriteLine($"srsly wth at depth {d} 1");
                throw new Exception($"srsly wth at depth {d} 1");
            }
            if (!cur.FullyExpanded)
            {
                try
                {
                    return cur.Expand(curBoard);
                }
                catch(Exception e)
                {
                    int i = 0;
                   foreach(Move m in mmss)
                   {
                       Console.Error.Write($"\"{m}\", ");
                       i++;
                       if (i % 4 == 0) Console.Error.WriteLine();
                   }
                    Console.Error.WriteLine($"I THINK (depth {d}):");
                    Console.Error.WriteLine(curBoard);
                    throw e;
                }
            }
            else
            {
                int winner = cur.BestChild(MyPlayerId);
                whomoves = 2;
                try
                {
                    curBoard.Move(cur.Moves[winner]);
                }
                catch(Exception ex)
                {
                    int i = 0;
                    foreach (Move m in mmss)
                    {
                        Console.Error.Write($"\"{m}\", ");
                        i++;
                        if (i % 4 == 0) Console.Error.WriteLine();
                    }
                    Console.Error.WriteLine($"I THINK (depth {d}):");
                    Console.Error.WriteLine(curBoard);
                    Console.Error.WriteLine($"NODE THINKs (depth {d}):");
                    Console.Error.WriteLine(cur.board);
                    throw ex;
                }
                d++;

                cur = cur.Children[winner];
                if (cur == null)
                {
                    throw new Exception($"srsly wth at depth {d} 2");
                }
            }
        }
        return cur;
    }


    int[] DefaultPolicy(Board curBoard)
    {
        int remBoxes = curBoard.remainingBoxes;
        while (curBoard.remainingBoxes > remBoxes * 0.9 && !curBoard.Terminal)
        {
            curBoard.RandomMove();
        }
        return curBoard.scores;
    }
    
}

class MCTNode
{
    public IEnumerable<Move>[] Moves;
    public int ChildrenCount;
    public MCTNode[] Children;
    public MCTNode Parent;
    public bool FullyExpanded { get { return expansion == ChildrenCount; } }
    public int TimesPulled;

    //mean score of a single player in this Node's state
    public float MeanScoreOfPlayer(int which)
    {
        return ((float)scores[which]) / TimesPulled;
    }

    public int[] scores;
    public int expansion;

    public MCTNode Expand(Board board)
    {
        MCT.whomoves = 3;
        try
        {
            board.Move(Moves[expansion]); //state(newChild) = f(state(this), move);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Node thinks: {this.board}");
            Console.Error.WriteLine($"To make it funnier: board.Legal(Moves[expansion]) = {this.board.Legal(Moves[expansion])}"); 

            throw ex;
        }
        Children[expansion] = new MCTNode(board, this); 
        expansion++;
        return Children[expansion - 1];
    }

    public int BestChild(int playerID)
    {
        int theOne = -1;
        float bestScore = int.MinValue;
        for (int i = 0; i < ChildrenCount; i++)
        {
            if (Children[i] != null)
            {
                float myScore = Children[i].MeanScoreOfPlayer(playerID);
                float theirScore = 0;
                float maxEnemy = 0;
                for (int j = 0; j < scores.Length; j++)
                {
                    if (j != playerID)
                    {
                        theirScore += Children[i].MeanScoreOfPlayer(j);
                        if (Children[i].MeanScoreOfPlayer(j) > maxEnemy)
                            maxEnemy = Children[i].MeanScoreOfPlayer(j);
                    }
                }
                theirScore /= scores.Length - 1;

                float score = (myScore - maxEnemy) * theirScore / (Math.Abs(myScore - theirScore) + 1);
                score += MCT.explorationRate * (float)Math.Sqrt(2 * Math.Log(TimesPulled) / Children[i].TimesPulled);
                if (score > bestScore)
                {
                    bestScore = score;
                    theOne = i;
                }
            }
        }
        if (theOne < 0)
            throw new Exception($"wat, but {ChildrenCount}! exp = {expansion} children[{0}] = {Children[0]!=null}");
        return theOne;
    }

    public Board board;

    public MCTNode(Board board, MCTNode par)
    {
        this.board = board.Copy();
        Moves = board.LegalMoves().OrderBy(x => MCT.random.Next()).ToArray();

        ChildrenCount = Moves.Length;

        Children = new MCTNode[ChildrenCount];
        Parent = par;
        TimesPulled = 0;
        expansion = 0;
        scores = new int[board.playersAmm];
    }
}

struct Entity : IEquatable<Entity>
{
    private uint _val;
    public Point position
    {
        get
        {
            return new Point(xPos, yPos);
        }
        set
        {
            yPos = (uint)value.y;
            xPos = (uint)value.x;
        }

    }

    // get: << (31-left) >> (31 - left + right)
    // set: << right

    public bool Equals(Entity e)
    {
        return (_val << 12) == (e._val << 12);
    }


    public bool empty //0-1, bit 19
    {
        //0 is empty
        get
        {
            return 0 == ((_val << 12) >> 31);
        }
        set
        {
            if (value)
                _val &= ~(uint)(1 << 19);
            else
                _val |= (1 << 19);
        }
    }
   
    public uint yPos // 0-15, bits 18 to 15
    {
        get
        {
            return (_val << 13) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("ypos is 0-15");
            _val &= ~(uint)(15 << 15);
            _val |= value << 15;
        }
    }
    public uint xPos // 0-15, bits 14 to 11
    {
        get
        {
            return (_val << 17) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("xpos is 0-15");
            _val &= ~(uint)(15 << 11);
            _val |= value << 11;
        }
    }

    /// <summary>
    /// 0 is player, 1 is bomb, 2 is item, 3 is box
    /// </summary>
    ///
    public uint type // 0-3, bits 10 to 9
    {
        get
        {
            return (_val << 21) >> 30;
        }
        set
        {
            if (value > 3)
                throw new Exception("type is 0-3");
            _val &= ~(uint)(3 << 9);
            _val |= value << 9;
        }
    }

    /// <summary>
    /// id of the player/player who put the bomb
    /// </summary>
    public uint owner // 0-1, 8th bit
    {
        get
        {
            return (_val << 23) >> 31;
        }
        set
        {
            if (value > 1)
                throw new Exception("owner is 0-1");
            _val &= ~(uint)(1 << 8);
            _val |= value << 8;
        }
    }

    /// <summary>
    /// bombs remaining / bomb timer / item type
    /// </summary>
    public uint param1 // 0-15, bits 7 to 4
    {
        get
        {
            return (_val << 24) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("param1 is 0-15");
            _val &= ~(uint)(15 << 4);
            _val |= value << 4;
        }
    }

    /// <summary>
    /// explosion range
    /// </summary>
    public uint param2 //0-15, bits 3 to 0
    {
        get
        {
            return (_val << 28) >> 28;
        }
        set
        {
            if (value > 15)
                throw new Exception("param2 is 0-15");
            _val &= ~(uint)15;
            _val |= value;
        }
    }

    public Entity(uint t, uint own, uint p1, uint p2, Point position)
    {
        _val = 0;
        this.position = position;
        type = t; owner = own; param1 = p1; param2 = p2;
        empty = false;
    }


    public override string ToString()
    {

        String t = "";
        if (empty)
            t = "(empty)";
        switch(type)
        {
            case 0:
                t+= "player";
                break;
            case 1:
                t+= "bomb";
                break;
            case 2:
                t+= "item";
                break;
        }
        return $"{t} of team {owner} at {position}, p1 {param1}, p2 {param2}";
    }
}

struct Point
{
    public int x;
    public int y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
    public Point(uint x, uint y)
    {
        this.x = (int)x;
        this.y = (int)y;
    }

    public IEnumerable<Point> Neighbours()
    {
        yield return new Point(x - 1, y);
        yield return new Point(x + 1, y);
        yield return new Point(x, y - 1);
        yield return new Point(x, y + 1);
    }

    public override string ToString()
    {
        return $"({x},{y})";
    }

    public static bool operator !=(Point p1, Point p2)
    {
        return (p1.x != p2.x || p1.y != p2.y);
    }

    public static bool operator ==(Point p1, Point p2)
    {
        return (p1.x == p2.x && p1.y == p2.y);
    }

}

struct Move
{
    public bool bomb;
    public Point destination;

    public Move(bool b, Point p)
    {
        bomb = b;
        destination = p;
    }

    public static bool operator !=(Move m1, Move m2)
    {
        return (m1.bomb != m2.bomb || m1.destination != m2.destination);
    }

    public static bool operator ==(Move m1, Move m2)
    {
        return (m1.bomb == m2.bomb && m1.destination == m2.destination);
    }

    public override string ToString()
    {
        String comm = bomb ? "BOMB" : "MOVE";
        return $"{comm} {destination.x} {destination.y}";
    }
}

class Grid
{
    Entity[,] ents;
    public uint height { get; private set; }
    public uint width { get; private set; }

    /// <summary>
    /// true if a player can move on this cell, false otherwise
    /// </summary>
    public bool free(int x, int y)
    {
        // false if cell out of bounds, is a box, or is a bomb
        return (InBounds(x, y) && (ents[y,x].empty || (ents[y, x].type != 3 && ents[y, x].type != 1)));
    }
    public bool free(Point p)
    {
        // false if cell out of bounds, is a box, or is a bomb
        return (InBounds(p) && (ents[p.y, p.x].empty || (ents[p.y, p.x].type != 3 && ents[p.y, p.x].type != 1)));
    }

    /// <summary>
    /// true if this cell stops a bomb's explosion
    /// </summary>
    public bool blocking(int x, int y)
    {
        // true if cell out of bounds, is a box, an item, or a bomb
        return (ents[y, x].type != 0 && !ents[y,x].empty);
    }
    public bool blocking(Point p)
    {
        // true if cell out of bounds, is a box, or is a bomb
        return (ents[p.y, p.x].type != 0);
    }

    public Entity this[Point p]
    {
        get
        {
            return ents[p.y, p.x];
        }
        set
        {
            ents[p.y, p.x] = value;
        }
    }

    public Entity this[int x, int y]
    {
        get
        {
            if (!InBounds(x, y))
                throw new Exception("blah");
            return ents[y, x];
        }
        set
        {
            ents[y, x] = value;
        }
    }

    public override String ToString()
    {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < height; i++)
        {
            for (int j = 0; j < width; j++)
            {
                if (this[j, i].empty)
                    builder.Append(".");
                else if (this[j, i].type == 3)
                {
                    builder.Append(this[j, i].param1);
                }
                else if (this[j,i].type == 1)
                {
                    builder.Append("b");
                }
                else if (this[j,i].type == 2)
                {
                    if (this[j, i].param1 == 1)
                        builder.Append("*");
                    else if (this[j, i].param1 == 2)
                        builder.Append("+");
                    else
                        builder.Append("?");
                }

            }
            builder.AppendLine();
        }
        return builder.ToString();
    }

    public bool InBounds(Point p)
    {
        return (p.x >= 0 && p.x < width && p.y >= 0 && p.y < height);
    }
    public bool InBounds(int x, int y)
    {
        return (x >= 0 && x < width && y >= 0 && y < height);
    }
    public bool InBounds(uint x, uint y)
    {
        return (x < width && y < height);
    }
    public Grid(uint width, uint height)
    {
        this.width = width;
        this.height = height;
        ents = new Entity[height,width];
    }
    public void CopyTo(Grid grid)
    {
        
        Array.Copy(ents, grid.ents, width * height);
    }

    public void UpdateRow(int which, String row)
    {
        for (int i = 0; i < row.Length; i++)
        {
            Entity t = new Entity();
            if (row[i] == '.')
                t.empty = true;
            else
            {
                t.empty = false;
                t.type = 3;
                t.param1 = (uint)(row[i] - 48);
            }
            ents[which, i] = t;
        }

    }
}
